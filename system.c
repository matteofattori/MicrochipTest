/****MODIFCATO DA FATTORI   *************************************************************************/
// This file contains various configuration and service routines, it also
// contains the IRQ functions
// Processor configuration can be found here
/******************************************************************************/
#include <string.h>
#include <stdio.h>
#include "main.h"
#include "system.h"
#include "math_u.h"
#include "consolle.h"
#include "dsp.h"
#include "I2C_driver.h"
#include "i2c_stam.h"
#include "p33EP256MC204.h"
#include "smps_control_library_vAugust_05_2016/smps_control.h"

// CONSTANTS --------------------------------------------------------------------
// waveform values
const unsigned int Sine_DDS_table[1024] = {0,100,201,301,402,502,603,703,804,904,1005,1105,1206,1306,1406,1507,1607,1708,1808,1908,2009,2109,2209,2310,2410,2510,2610,2711,2811,2911,3011,3111,3211,3311,3411,
3511,3611,3711,3811,3911,4011,4110,4210,4310,4409,4509,4608,4708,4807,4907,5006,5106,5205,5304,5403,5502,5601,5700,5799,5898,5997,6096,6195,6293,6392,6491,6589,6688,6786,
6884,6982,7081,7179,7277,7375,7473,7571,7668,7766,7864,7961,8059,8156,8253,8351,8448,8545,8642,8739,8836,8932,9029,9126,9222,9319,9415,9511,9607,9703,9799,9895,9991,10087,
10182,10278,10373,10469,10564,10659,10754,10849,10944,11038,11133,11227,11322,11416,11510,11604,11698,11792,11886,11980,12073,12166,12260,12353,12446,12539,12632,12724,
12817,12909,13002,13094,13186,13278,13370,13462,13553,13645,13736,13827,13918,14009,14100,14191,14281,14372,14462,14552,14642,14732,14822,14911,15001,15090,15179,15268,
15357,15446,15534,15623,15711,15799,15887,15975,16063,16150,16238,16325,16412,16499,16586,16672,16759,16845,16931,17017,17103,17189,17274,17360,17445,17530,17615,17699,
17784,17868,17952,18036,18120,18204,18287,18371,18454,18537,18620,18702,18785,18867,18949,19031,19113,19194,19276,19357,19438,19519,19599,19680,19760,19840,19920,20000,
20079,20159,20238,20317,20396,20474,20553,20631,20709,20787,20864,20942,21019,21096,21173,21249,21326,21402,21478,21554,21629,21705,21780,21855,21930,22004,22079,22153,
22227,22301,22374,22448,22521,22594,22666,22739,22811,22883,22955,23027,23098,23169,23240,23311,23382,23452,23522,23592,23661,23731,23800,23869,23938,24006,24075,24143,
24211,24278,24346,24413,24480,24546,24613,24679,24745,24811,24877,24942,25007,25072,25136,25201,25265,25329,25392,25456,25519,25582,25645,25707,25769,25831,25893,25954,
26016,26077,26137,26198,26258,26318,26378,26437,26497,26556,26615,26673,26731,26789,26847,26905,26962,27019,27076,27132,27188,27244,27300,27355,27411,27466,27520,27575,
27629,27683,27736,27790,27843,27896,27948,28001,28053,28105,28156,28208,28259,28309,28360,28410,28460,28510,28559,28608,28657,28706,28754,28802,28850,28897,28945,28992,
29038,29085,29131,29177,29222,29268,29313,29358,29402,29446,29490,29534,29577,29621,29663,29706,29748,29790,29832,29873,29915,29955,29996,30036,30076,30116,30156,30195,
30234,30272,30311,30349,30386,30424,30461,30498,30535,30571,30607,30643,30678,30713,30748,30783,30817,30851,30885,30918,30951,30984,31017,31049,31081,31113,31144,31175,
31206,31236,31267,31297,31326,31356,31385,31413,31442,31470,31498,31525,31553,31580,31606,31633,31659,31684,31710,31735,31760,31785,31809,31833,31856,31880,31903,31926,
31948,31970,31992,32014,32035,32056,32077,32097,32117,32137,32156,32176,32194,32213,32231,32249,32267,32284,32301,32318,32334,32350,32366,32382,32397,32412,32426,32441,
32455,32468,32482,32495,32508,32520,32532,32544,32556,32567,32578,32588,32599,32609,32618,32628,32637,32646,32654,32662,32670,32678,32685,32692,32699,32705,32711,32717,
32722,32727,32732,32736,32740,32744,32746,32748,32750,32751,32752,32753,32754,32755,32757,32759,32763,32767,32763,32759,32757,32755,32754,32753,32754,32753,32752,32751,
32748,32744,32740,32736,32732,32727,32722,32717,32711,32705,32699,32692,32685,32678,32670,32662,32654,32646,32637,32628,32618,32609,32599,32588,32578,32567,32556,32544,
32532,32520,32508,32495,32482,32468,32455,32441,32426,32412,32397,32382,32366,32350,32334,32318,32301,32284,32267,32249,32231,32213,32194,32176,32156,32137,32117,32097,
32077,32056,32035,32014,31992,31970,31948,31926,31903,31880,31856,31833,31809,31785,31760,31735,31710,31684,31659,31633,31606,31580,31553,31525,31498,31470,31442,31413,
31385,31356,31326,31297,31267,31236,31206,31175,31144,31113,31081,31049,31017,30984,30951,30918,30885,30851,30817,30783,30748,30713,30678,30643,30607,30571,30535,30498,
30461,30424,30386,30349,30311,30272,30234,30195,30156,30116,30076,30036,29996,29955,29915,29873,29832,29790,29748,29706,29663,29621,29577,29534,29490,29446,29402,29358,
29313,29268,29222,29177,29131,29085,29038,28992,28945,28897,28850,28802,28754,28706,28657,28608,28559,28510,28460,28410,28360,28309,28259,28208,28156,28105,28053,28001,
27948,27896,27843,27790,27736,27683,27629,27575,27520,27466,27411,27355,27300,27244,27188,27132,27076,27019,26962,26905,26847,26789,26731,26673,26615,26556,26497,26437,
26378,26318,26258,26198,26137,26077,26016,25954,25893,25831,25769,25707,25645,25582,25519,25456,25392,25329,25265,25201,25136,25072,25007,24942,24877,24811,24745,24679,
24613,24546,24480,24413,24346,24278,24211,24143,24075,24006,23938,23869,23800,23731,23661,23592,23522,23452,23382,23311,23240,23169,23098,23027,22955,22883,22811,22739,
22666,22594,22521,22448,22374,22301,22227,22153,22079,22004,21930,21855,21780,21705,21629,21554,21478,21402,21326,21249,21173,21096,21019,20942,20864,20787,20709,20631,
20553,20474,20396,20317,20238,20159,20079,20000,19920,19840,19760,19680,19599,19519,19438,19357,19276,19194,19113,19031,18949,18867,18785,18702,18620,18537,18454,18371,
18287,18204,18120,18036,17952,17868,17784,17699,17615,17530,17445,17360,17274,17189,17103,17017,16931,16845,16759,16672,16586,16499,16412,16325,16238,16150,16063,15975,
15887,15799,15711,15623,15534,15446,15357,15268,15179,15090,15001,14911,14822,14732,14642,14552,14462,14372,14281,14191,14100,14009,13918,13827,13736,13645,13553,13462,
13370,13278,13186,13094,13002,12909,12817,12724,12632,12539,12446,12353,12260,12166,12073,11980,11886,11792,11698,11604,11510,11416,11322,11227,11133,11038,10944,10849,
10754,10659,10564,10469,10373,10278,10182,10087,9991,9895,9799,9703,9607,9511,9415,9319,9222,9126,9029,8932,8836,8739,8642,8545,8448,8351,8253,8156,8059,7961,7864,7766,
7668,7571,7473,7375,7277,7179,7081,6982,6884,6786,6688,6589,6491,6392,6293,6195,6096,5997,5898,5799,5700,5601,5502,5403,5304,5205,5106,5006,4907,4807,4708,4608,4509,4409,
4310,4210,4110,4011,3911,3811,3711,3611,3511,3411,3311,3211,3111,3011,2911,2811,2711,2610,2510,2410,2310,2209,2109,2009,1908,1808,1708,1607,1507,1406,1306,1206,1105,1005,
904,804,703,603,502,402,301,201,100};

const unsigned int Star_DDS_table[1024] = {
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,0x0000,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
};

const unsigned int Square_DDS_table[1024] = {
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,0x7FFF,
};

const unsigned int Tria_DDS_table[1024] = {0,64,128,192,256,320,384,448,512,576,640,704,768,832,896,960,1024,1088,1152,1216,1280,1344,1408,1472,1536,1600,1664,1728,1792,1856,1920,1984,2048,2112,2176,2240,2304,2368,2432,2496,
2560,2624,2688,2752,2816,2880,2944,3008,3072,3136,3200,
3264	,
3328	,
3392	,
3456	,
3520	,
3584	,
3648	,
3712	,
3776	,
3840	,
3904	,
3968	,
4032	,
4096	,
4160	,
4224	,
4288	,
4352	,
4416	,
4480	,
4544	,
4608	,
4672	,
4736	,
4800	,
4864	,
4928	,
4992	,
5056	,
5120	,
5184	,
5248	,
5312	,
5376	,
5440	,
5504	,
5568	,
5632	,
5696	,
5760	,
5824	,
5888	,
5952	,
6016	,
6080	,
6144	,
6208	,
6272	,
6336	,
6400	,
6464	,
6528	,
6592	,
6656	,
6720	,
6784	,
6848	,
6912	,
6976	,
7040	,
7104	,
7168	,
7232	,
7296	,
7360	,
7424	,
7488	,
7552	,
7616	,
7680	,
7744	,
7808	,
7872	,
7936	,
8000	,
8064	,
8128	,
8192	,
8256	,
8320	,
8384	,
8448	,
8512	,
8576	,
8640	,
8704	,
8768	,
8832	,
8896	,
8960	,
9024	,
9088	,
9152	,
9216	,
9280	,
9344	,
9408	,
9472	,
9536	,
9600	,
9664	,
9728	,
9792	,
9856	,
9920	,
9984	,
10048	,
10112	,
10176	,
10240	,
10304	,
10368	,
10432	,
10496	,
10560	,
10624	,
10688	,
10752	,
10816	,
10880	,
10944	,
11008	,
11072	,
11136	,
11200	,
11264	,
11328	,
11392	,
11456	,
11520	,
11584	,
11648	,
11712	,
11776	,
11840	,
11904	,
11968	,
12032	,
12096	,
12160	,
12224	,
12288	,
12352	,
12416	,
12480	,
12544	,
12608	,
12672	,
12736	,
12800	,
12864	,
12928	,
12992	,
13056	,
13120	,
13184	,
13248	,
13312	,
13376	,
13440	,
13504	,
13568	,
13632	,
13696	,
13760	,
13824	,
13888	,
13952	,
14016	,
14080	,
14144	,
14208	,
14272	,
14336	,
14400	,
14464	,
14528	,
14592	,
14656	,
14720	,
14784	,
14848	,
14912	,
14976	,
15040	,
15104	,
15168	,
15232	,
15296	,
15360	,
15424	,
15488	,
15552	,
15616	,
15680	,
15744	,
15808	,
15872	,
15936	,
16000	,
16064	,
16128	,
16192	,
16256	,
16320	,
16384	,
16448	,
16512	,
16576	,
16640	,
16704	,
16768	,
16832	,
16896	,
16960	,
17024	,
17088	,
17152	,
17216	,
17280	,
17344	,
17408	,
17472	,
17536	,
17600	,
17664	,
17728	,
17792	,
17856	,
17920	,
17984	,
18048	,
18112	,
18176	,
18240	,
18304	,
18368	,
18432	,
18496	,
18560	,
18624	,
18688	,
18752	,
18816	,
18880	,
18944	,
19008	,
19072	,
19136	,
19200	,
19264	,
19328	,
19392	,
19456	,
19520	,
19584	,
19648	,
19712	,
19776	,
19840	,
19904	,
19968	,
20032	,
20096	,
20160	,
20224	,
20288	,
20352	,
20416	,
20480	,
20544	,
20608	,
20672	,
20736	,
20800	,
20864	,
20928	,
20992	,
21056	,
21120	,
21184	,
21248	,
21312	,
21376	,
21440	,
21504	,
21568	,
21632	,
21696	,
21760	,
21824	,
21888	,
21952	,
22016	,
22080	,
22144	,
22208	,
22272	,
22336	,
22400	,
22464	,
22528	,
22592	,
22656	,
22720	,
22784	,
22848	,
22912	,
22976	,
23040	,
23104	,
23168	,
23232	,
23296	,
23360	,
23424	,
23488	,
23552	,
23616	,
23680	,
23744	,
23808	,
23872	,
23936	,
24000	,
24064	,
24128	,
24192	,
24256	,
24320	,
24384	,
24448	,
24512	,
24576	,
24640	,
24704	,
24768	,
24832	,
24896	,
24960	,
25024	,
25088	,
25152	,
25216	,
25280	,
25344	,
25408	,
25472	,
25536	,
25600	,
25664	,
25728	,
25792	,
25856	,
25920	,
25984	,
26048	,
26112	,
26176	,
26240	,
26304	,
26368	,
26432	,
26496	,
26560	,
26624	,
26688	,
26752	,
26816	,
26880	,
26944	,
27008	,
27072	,
27136	,
27200	,
27264	,
27328	,
27392	,
27456	,
27520	,
27584	,
27648	,
27712	,
27776	,
27840	,
27904	,
27968	,
28032	,
28096	,
28160	,
28224	,
28288	,
28352	,
28416	,
28480	,
28544	,
28608	,
28672	,
28736	,
28800	,
28864	,
28928	,
28992	,
29056	,
29120	,
29184	,
29248	,
29312	,
29376	,
29440	,
29504	,
29568	,
29632	,
29696	,
29760	,
29824	,
29888	,
29952	,
30016	,
30080	,
30144	,
30208	,
30272	,
30336	,
30400	,
30464	,
30528	,
30592	,
30656	,
30720	,
30784	,
30848	,
30912	,
30976	,
31040	,
31104	,
31168	,
31232	,
31296	,
31360	,
31424	,
31488	,
31552	,
31616	,
31680	,
31744	,
31808	,
31872	,
31936	,
32000	,
32064	,
32128	,
32192	,
32256	,
32320	,
32384	,
32448	,
32512	,
32576	,
32640	,
32704	,
32640	,
32576	,
32512	,
32448	,
32384	,
32320	,
32256	,
32192	,
32128	,
32064	,
32000	,
31936	,
31872	,
31808	,
31744	,
31680	,
31616	,
31552	,
31488	,
31424	,
31360	,
31296	,
31232	,
31168	,
31104	,
31040	,
30976	,
30912	,
30848	,
30784	,
30720	,
30656	,
30592	,
30528	,
30464	,
30400	,
30336	,
30272	,
30208	,
30144	,
30080	,
30016	,
29952	,
29888	,
29824	,
29760	,
29696	,
29632	,
29568	,
29504	,
29440	,
29376	,
29312	,
29248	,
29184	,
29120	,
29056	,
28992	,
28928	,
28864	,
28800	,
28736	,
28672	,
28608	,
28544	,
28480	,
28416	,
28352	,
28288	,
28224	,
28160	,
28096	,
28032	,
27968	,
27904	,
27840	,
27776	,
27712	,
27648	,
27584	,
27520	,
27456	,
27392	,
27328	,
27264	,
27200	,
27136	,
27072	,
27008	,
26944	,
26880	,
26816	,
26752	,
26688	,
26624	,
26560	,
26496	,
26432	,
26368	,
26304	,
26240	,
26176	,
26112	,
26048	,
25984	,
25920	,
25856	,
25792	,
25728	,
25664	,
25600	,
25536	,
25472	,
25408	,
25344	,
25280	,
25216	,
25152	,
25088	,
25024	,
24960	,
24896	,
24832	,
24768	,
24704	,
24640	,
24576	,
24512	,
24448	,
24384	,
24320	,
24256	,
24192	,
24128	,
24064	,
24000	,
23936	,
23872	,
23808	,
23744	,
23680	,
23616	,
23552	,
23488	,
23424	,
23360	,
23296	,
23232	,
23168	,
23104	,
23040	,
22976	,
22912	,
22848	,
22784	,
22720	,
22656	,
22592	,
22528	,
22464	,
22400	,
22336	,
22272	,
22208	,
22144	,
22080	,
22016	,
21952	,
21888	,
21824	,
21760	,
21696	,
21632	,
21568	,
21504	,
21440	,
21376	,
21312	,
21248	,
21184	,
21120	,
21056	,
20992	,
20928	,
20864	,
20800	,
20736	,
20672	,
20608	,
20544	,
20480	,
20416	,
20352	,
20288	,
20224	,
20160	,
20096	,
20032	,
19968	,
19904	,
19840	,
19776	,
19712	,
19648	,
19584	,
19520	,
19456	,
19392	,
19328	,
19264	,
19200	,
19136	,
19072	,
19008	,
18944	,
18880	,
18816	,
18752	,
18688	,
18624	,
18560	,
18496	,
18432	,
18368	,
18304	,
18240	,
18176	,
18112	,
18048	,
17984	,
17920	,
17856	,
17792	,
17728	,
17664	,
17600	,
17536	,
17472	,
17408	,
17344	,
17280	,
17216	,
17152	,
17088	,
17024	,
16960	,
16896	,
16832	,
16768	,
16704	,
16640	,
16576	,
16512	,
16448	,
16384	,
16320	,
16256	,
16192	,
16128	,
16064	,
16000	,
15936	,
15872	,
15808	,
15744	,
15680	,
15616	,
15552	,
15488	,
15424	,
15360	,
15296	,
15232	,
15168	,
15104	,
15040	,
14976	,
14912	,
14848	,
14784	,
14720	,
14656	,
14592	,
14528	,
14464	,
14400	,
14336	,
14272	,
14208	,
14144	,
14080	,
14016	,
13952	,
13888	,
13824	,
13760	,
13696	,
13632	,
13568	,
13504	,
13440	,
13376	,
13312	,
13248	,
13184	,
13120	,
13056	,
12992	,
12928	,
12864	,
12800	,
12736	,
12672	,
12608	,
12544	,
12480	,
12416	,
12352	,
12288	,
12224	,
12160	,
12096	,
12032	,
11968	,
11904	,
11840	,
11776	,
11712	,
11648	,
11584	,
11520	,
11456	,
11392	,
11328	,
11264	,
11200	,
11136	,
11072	,
11008	,
10944	,
10880	,
10816	,
10752	,
10688	,
10624	,
10560	,
10496	,
10432	,
10368	,
10304	,
10240	,
10176	,
10112	,
10048	,
9984	,
9920	,
9856	,
9792	,
9728	,
9664	,
9600	,
9536	,
9472	,
9408	,
9344	,
9280	,
9216	,
9152	,
9088	,
9024	,
8960	,
8896	,
8832	,
8768	,
8704	,
8640	,
8576	,
8512	,
8448	,
8384	,
8320	,
8256	,
8192	,
8128	,
8064	,
8000	,
7936	,
7872	,
7808	,
7744	,
7680	,
7616	,
7552	,
7488	,
7424	,
7360	,
7296	,
7232	,
7168	,
7104	,
7040	,
6976	,
6912	,
6848	,
6784	,
6720	,
6656	,
6592	,
6528	,
6464	,
6400	,
6336	,
6272	,
6208	,
6144	,
6080	,
6016	,
5952	,
5888	,
5824	,
5760	,
5696	,
5632	,
5568	,
5504	,
5440	,
5376	,
5312	,
5248	,
5184	,
5120	,
5056	,
4992	,
4928	,
4864	,
4800	,
4736	,
4672	,
4608	,
4544	,
4480	,
4416	,
4352	,
4288	,
4224	,
4160	,
4096	,
4032	,
3968	,
3904	,
3840	,
3776	,
3712	,
3648	,
3584	,
3520	,
3456	,
3392	,
3328	,
3264	,
3200	,
3136	,
3072	,
3008	,
2944	,
2880	,
2816	,
2752	,
2688	,
2624	,
2560	,
2496	,
2432	,
2368	,
2304	,2240,2176,2112,2048,1984,1920,1856,1792,1728,1664,1600,1536,1472,1408,1344,1280,1216,1152,1088,1024,960,896,832,768,704,640,576,512,448,384,320,256,192,128,64,
0,};


// VARIABLES --------------------------------------------------------------------
// V, I, Vsupply, Trafo temp ADC buffer values (raw data, as acquired from ADC)
//configurazione a 12bit
#ifdef _12bit
struct  {   int V_CH;   // CH0, AN0, RA0 tensione in uscita 
            int I_CH;   // CH0, AN1, RA1 corrente in uscita
            int V_SP;   // CH0, AN2, RB0 alimentazione ponte 
            int IlowCH;   // CH0, AN5, RB3 XWB cambiato prima si leggeva il trafo ora la corrente dall'effetto hall prima era TTMP
        } ADC __attribute__((far, space(ymemory)));
#endif
#ifdef _10bit        
struct  {  
            int IlowCH;  // CH0, AN5, RB3 corrente sensibile 
            int V_CH;   // CH1, AN0, RA0 tensione uscita
            int I_CH;   // CH2, AN1, RB1 corrente uscita 
            int V_SP;   // CH3, AN2, RB0 tensione alimenta 
        } ADC __attribute__((far, space(ymemory)));        
#endif        
// offset values, used to compensate analog front end
int V_offset = 0;
int I_offset = 0;
int Ilow_offset =0; //XWB aggiunta per il calcolo dell'offset della Ilow

// SW TIMERS, used to generate delays, 40us timebase
unsigned long TIMER_0;
unsigned int TIMER_I2C;
unsigned long TIMER_MINUTE = _1min;
unsigned int RX_timeout;
extern unsigned char set_PWM;


// DMA1 TX buffer - UART to consolle
char string[c_str_l];
char char_buffer;

// DMA2 TX buffer - UART to control port
extern char TX_buffer[256];

     int pwm, npwm;
int temp_SPI;

// PID controller structure
#ifdef _PID
tPID PID_DATA;
#endif

// 3P3Z controller structure
#ifdef _3P3Z
SMPS_3P3Z_T str_3p3z;
#endif

// dsp PID controller structure
#ifdef _dspPID
SMPS_PID_T str_PID;
#endif
const long k0 = _k_gain;                                    // controller gain
int gain;                                                   // controller gain, scaled with Vline

#ifdef _PID
int abc_coeff[3] __attribute__((space(xmemory)));           // a,b,c coefficients in Xmem
int pid_coeff[3];                                           // in order: [Kp, Ki, Kd]
int ctrl_hyst[3] __attribute__((far, space(ymemory)));      // old out samples in Ymem
int pid_V_coeff[3];                                         // regulator's parameters
int pid_V_18Vcoeff[3];                                      // XWB parametri PID scala 18V
int pid_I_coeff[3];                                         // regulator's parameters
#endif

#ifdef _3P3Z
int A_coeff[3] __attribute__((space(xmemory)));             // A coefficients
int B_coeff[4] __attribute__((space(xmemory)));             // B coefficients
int ctrl_hist[3] __attribute__((far, space(ymemory)));      // control history array
int ctrl_err[4] __attribute__((far, space(ymemory)));       // control error history array
#endif

#ifdef _dspPID
int ABC_coeff[3] __attribute__((space(xmemory)));           // A, B, C coefficients
int ctrl_err[3] __attribute__((far, space(ymemory)));       // control error history array
#endif

int PWM_freq;
int PWM_max;
int PWM_min;
int PWM_max_duty;
int PWM_mid_duty;
int PWM_dead_time;

int data_buffer;                                             // data input for waveform generation
                               // variable is update both from SPI or
                               // from intenal LUT (array sine[])
float scale = _min_scale;        // waveform scaling, amplitude control min_scale=0 scala utilizzata per il loop aperto
float scaleV = _min_scale;       // usata per ridurre il reference della tensione quando controllo spi, scala usata per il loop in tensione
float scaleI = _min_scale;       // usata per ridurre il ref della corrente con la spi    ,scala usata per il loop di corrente
float scaleO = _min_scale;       // scala usata nel controllo aperto prima si usava direttamente scale
// voltage and current value that feed PID or 3P3Z controller (filtered but raw data)
struct  {   
            int V;      // feedback voltage signal filtered- non è filtrato, è in codice ADC 7FFF-8000
            int I;      // feedback current signal filtered
            int Ilow;   //XWB aggiunta per inserire la lettura di corrente più sensibile
        } feedback;

// voltage and current limits structure: voltage and current have hysteresis
struct  {   
            int V;      // voltage limit (rising)
            int nV;     // voltage limit (falling)
            int I;      // current limit (rising)
            int nI;     // current limit (falling)
            int VS;     // voltage shutdown limit (Vlimit + 50%)
            int IS;     // current shutdown limit (Ilimit + 50%)
        }limit;
     
        // Signal generator with DDS structure
struct  {  
            unsigned long M;     // phase accumulator increment
            unsigned long PHA;   // phase accumulator
        }DDS;

extern cycle_str_type CYCLES[15];       // cycles data structure
unsigned long   timer_cycle = 0;        // length of cycle in [ms]

int v1[512], v2[512], v3[512], v4[512];                     // DEBUG arrays

void init_ic2_400khz(void){
        // I2C Module ---------------------------------------------------------------
    I2C1CON = 0b0000000100000000;                   // disable I2C, enable SMBUS logic level compliance
    I2C1BRG = 0x004f;                              // set minimum device's bus frequency (~400kHz)
      
    I2C1STAT = 0x0000;                              // clear status register
    I2C1CONbits.I2CEN = 1;                          // enable peripheral    
}

void init_ic2_100khz(void){
        // I2C Module ---------------------------------------------------------------
    I2C1CON = 0b0000000100000000;                   // disable I2C, enable SMBUS logic level compliance
    I2C1BRG = 0x001FF;                              // set minimum device's bus frequency (~112kHz)
      
    I2C1STAT = 0x0000;                              // clear status register
    I2C1CONbits.I2CEN = 1;                          // enable peripheral    
}

void presettings(void){
    init_ic2_100khz();
    VscaleEN(0); 
    FLAGS.SCALE = 0;
}
// SYSTEM Configuration ---------------------------------------------------------
void cfg_PWM(unsigned char set)
{
    switch (set)
    {
        case 0:    // 3_level_PWM            
            IOCON3 =  0xC000;  //0b1100000000000000;       //...pins go low if in fault mode
            IOCON2 =  0xC000;
            PWMCON2 = 0x0605;  //0b0000011000000101;       // set independent time bases, center aligned mode, independent duty cycles
            PWMCON3 = 0x0205;  //0b0000001000000101;       // enable irq on trigger event on PWM2, immediate period update
            TRGCON2 = 0x3000; 
            PWM_freq = 1200; //era 1200
            PWM_max = 580;//era540  520 va nello squadratore 540 lo regge solo se è caricata l'uscita ;
            PWM_min = -580;//era -520;
            PWM_max_duty = 1200;
            PWM_mid_duty = 600;
            // set PWM dead time: ALTDTRx = fosc * (dead_time / PWM prescaler)
            PWM_dead_time = 50;   
            PHASE2 = PHASE3 = PWM_freq;                    // set PWM frequency   
            PDC3 = PDC2 = PWM_freq >> 1;                   // set current duty-cycle          
            DTR2 = DTR3 = PWM_dead_time;                   // set dead time
            ALTDTR2 = ALTDTR3 = PWM_dead_time;             // set dead time          
            break;
        case 1:   //50kHz PWM             
            IOCON3 = 0xC002;//0b1100000000000010;           // ...pins go low if in fault mode
            IOCON2 = 0xC000;
            PWMCON2 = 0x0601;//0b0000011000000001;          // set independent time bases, complementary mode, independent duty cycles
            PWMCON3 = 0x0201;//0b0000001000000001;          // enable irq on trigger event on PWM2, immediate period update
            TRGCON2 = 0x1000;                               // trigger every two PWM cycles
            // set PWM period to 50kHz in complementary mode: PHASEx = fosc / (fPWM * PWM prescaler)
            PWM_freq = 2400;
            PWM_max = 1100;
            PWM_min = -1100;
            PWM_max_duty = 2400;
            PWM_mid_duty = 1200;
            // set PWM dead time: ALTDTRx = fosc * (dead_time / PWM prescaler)
            PWM_dead_time = 50;                                                        
            // High Speed PWM -----------------------------------------------------------
            PHASE2 = PHASE3 = PWM_freq;                    // set PWM frequency   
            PDC2 = PDC3 = PWM_freq >> 1;                   // set current duty-cycle
            DTR2 = DTR3 = PWM_dead_time;  
            ALTDTR2 = ALTDTR3 = PWM_dead_time;              // set dead time
            break;       
        case 2:    //100kHz PWM          
            IOCON3 = 0xC002;//0b1100000000000010;          // ...pins go low if in fault mode
            IOCON2 = 0xC000;
            PWMCON2 = 0x0601;//0b0000011000000001;          // set independent time bases, complementary mode, independent duty cycles
            PWMCON3 = 0x0601;//0b0000001000000001;          // enable irq on trigger event on PWM2, immediate period update             
            TRGCON2 = 0x3000;                               // trigger every four PWM cycles 
            PWM_freq = 1200;
            PWM_max = 450;
            PWM_min = -450;
            PWM_max_duty = 1200;
            PWM_mid_duty = 600;           
            PWM_dead_time = 50;
            // High Speed PWM -----------------------------------------------------------           
            PHASE2 = PHASE3 = PWM_freq;                     // set PWM frequency   
            PDC2 = PDC3 = PWM_freq >> 1;                    // set current duty-cycle 
            DTR2 = DTR3 = PWM_dead_time;  
            ALTDTR2 = ALTDTR3 = PWM_dead_time;              // set dead time
           
            break;
        case 3:    // push-pull   
                       // set dead time
            
            /*
            IOCON3 = 0xC802;
            IOCON2 = 0xC800;
            PWMCON2 = 0x0300;
            PWMCON3 = 0x0300;
            //PHASE1 = 1000;       
            PHASE2 = 400;
            PHASE3 = 400;       
            MDC = 10; 
            */
           // DTR2 = DTR3 = 25;
            //ALTDTR2 = ALTDTR3 = 25;
            //PTCON2 = 0x0000;
        break;
    }
 }

void cfg_system(void)
{
       
    // I / O configuration ------------------------------------------------------
    ANSELA = 0x0003;								// AN0, AN1 are analog inputs
    ANSELB = 0x000B;                                // RB0, RB1, RB3 are analog inputs
    ANSELC = 0x0003;

	PORTA = ZERO;
	TRISA = 0b0000001100000011;
	//	A15		-
	//	A14		-
	//	A13		-
	//	A12		-
	//	A11		-
	//	A10		n.c.
	//	A9		SPI MOSI (input)
	//	A8		U2RX
	//	A7		GPIO2 (OUT)
	//	A6		-
	//	A5		-
	//	A4		SPI MISO (output)
	//	A3		ox
	//	A2		ox
	//	A1		Analog INPUT AN1 (I)
	//	A0		Analog INPUT AN0 (V)

	PORTB = 0b0000000100000000;
	TRISB = 0b1100000000001111;
	//	B15		BOOT ENABLE (input)
	//	B14		U1RX consolle
	//	B13		PWM1L2 (out)
	//	B12		PWM1H2 (out)
	//	B11		PWM1L3 (out)
	//	B10		PWM1H3 (out)
	//	B9		U1TX consolle
	//	B8		Driver shutdown (out), normally disabled
	//	B7		GPIO1 (OUT)
	//	B6		PGC
	//	B5		PGD
	//	B4		U2TX
	//	B3		Analog INPUT AN5 (NTC)
	//	B2		SPI SS (input)
	//	B1		Analog INPUT AN3 (ADC Vref)
	//	B0		Analog INPUT AN2 (V_line)

	PORTC = ZERO;
	TRISC = 0b0000000000001111;
	//	C15		-
	//	C14		-
	//	C13		-
	//	C12		-
	//	C11		-
	//	C10		-
	//	C9		CAL V (out)
	//	C8		CAL I (out)
	//	C7		DL1 (out)
	//	C6		DL2 (out)
	//	C5		I2C SCL
	//	C4		I2C SDA
	//	C3		SPI CLK (input)
	//	C2		GPIO3 (input)
	//	C1		Power fault reference (analog)
	//	C0		Power fault (analog)
    
	// CLOCK CONFIGURATION ------------------------------------------------------
	// system starts with internal ox, primary ox disabled
    PLLFBD = 0x002E;								// M = 48
	CLKDIV = 0b0000000000000010;					// set fin = 20MHz / 4; N1 = 2; N2 = 2
                                    // fosc = Fin x M / N1 / N2 = 120MHz -> 60MIPS
                                    // fcy = fosc/2 = 60MHz
	// unlock sequence...
	__builtin_write_OSCCONH(0x23);					// set ck destination: prim ox with PLL
    
	__builtin_write_OSCCONL(0x01);					// enable switch

	while(OSCCONbits.OSWEN);						// wait switching...
    	
    //__builtin_write_PWMSFR(&IOCON1, 0b0000000000000000, &PWMKEY);
    //__builtin_write_PWMSFR(&IOCON2, 0b1100000000000000, &PWMKEY);
    //__builtin_write_PWMSFR(&IOCON3, 0b1100000000000000, &PWMKEY);
    
    IOCON1 = 0b0000000000000000;                    // release PWM1L, PWM1H pins
    IOCON2 = 0b1100000000000000;                    // set push-pull mode on PWMxL and PWMxH and...
            
            // invert pwm logic level in pwm3 for complementary mode       
                                                    // disable irq on fault event on PWM2: it will be driven by PWM2    
    FCLCON2 = 0b0000000001011001;                   // enable faults on COMP4OUT for PWM2 and 3, active high,
    FCLCON3 = 0b0000000001011001;                   // force PWMH,L to safety levels in cycle mode
    
    TRIG2 = 0x0000;                                 // trigger ADC on start of pwm period    
    
    PTCON2 = 0b0000000000000000;                    // set PWM prescaler to :1
    
    // Blanking circuitry for fault detection -----------------------------------
    LEBCON2 = 0b1111100000000000;                   // enable Leading edge Blanking on
                                    // PWM2, falling and rising edges, disable state blanking
    LEBDLY2 = 0x0003;                               // LEB duration = 1 / Tosc * LEBDLY = 8.3ns * 3 = 25ns
    
    LEBCON3 = 0b1111100000000000;                   // enable Leading edge Blanking on
                                                    // PWM3, falling and rising edges, disable state blanking
    LEBDLY3 = 0x0003;                               // LEB duration = 1 / Tosc * LEBDLY = 8.3ns * 3 = 25ns
    
    // Comparator for overcurrent detection -------------------------------------
    RPOR5 = RPOR5 | 0x3200;
    CMSTAT = 0x0000;                                // continue operation in idle mode
    CM4CON = 0b0100000001000000;                    // disable comp., out enabled, comparator mode,
                                    // direct polarity, irq on low to high, V+ is C4IN+, v- is C4IN-
    CM4CONbits.CON = 1;                             // enable comparator

    PTCONbits.PTEN = 1;                             // enable PWM
    PWM_IRQ_ENABLE;                                 // and its interrupt

    // ADC ----------------------------------------------------------------------
#ifdef _12bit
    AD1CON1 = 0b0001011100110100;  //12bit          // 12 bit mode, signed fractional format
              //5432109876543210                    // write data in order of conversion, trigger from PWM2
    AD1CON2 = 0b0010010000001100;                   // External Vref, convert CH0
    AD1CHS0 = 0b0000000000000000;                   // cambaito da Mazzaara per il 12bit
                                                    // CH0: AN1
    AD1CSSL = 0x27;                                 // scansione            
#endif
#ifdef _10bit   
    AD1CON1 = 0b0001001100111100;                   //10bit     
    AD1CON2 = 0b0010001000000000;                   //10bit External Vref, convert CH0, CH1, CH2, CH3, increment DMA addr after each conversion
    // increment DMA addr after each conversion
    AD1CHS0 = 0b0000000000000101;                   // MUXA: negative in is Vrefl, positive:
                                                    // CH0: AN1
    AD1CSSL = 0b0000000000000000; //no scansione
    // always starts filling from start address
#endif
    
    AD1CON3 = 0b0000000000001001;                   // use ck freq, fad = fcy / (M + 1) = 60MHz / 10 = 6MHz
              //5432109876543210                    // tad = 1 / fad = 166.6ns -> tconv = 12 * tad = 2us
                                                    // fconv ch1-ch2 = 1 / (tconv * 2) = 250ksps
    AD1CON4 =   0b0000000100000000;                   // use DMA, 1 word buffer for each analog IN
                //5432109876543210 
    
    AD1CHS123 = 0b0000000000000000;                 // MUXA: negative in is Vrefl, positive:
                                                    // CH1: AN0 - V
                                                    // CH2: AN1 - I
                                                    // CH3: AN2 - Vline
    AD1CSSH = 0b0000000000000000;                   // no scan select 
   
        
	// Set DMA channel 0 for ADC data transfer ----------------------------------
    DMA0CON = 0b0000000000000000;					// disabled, word transfer, from peripheral to DMARAM,
                                                    // peripheral post-increment, continuous transfer
    DMA0REQ = 0b0000000000001101;                   // auto transfer, use ADC irq to start transfer
    DMA0STAH = 0x0000;                              // load DMA buffer address
    DMA0STAL = __builtin_dmaoffset(&ADC);
    DMA0PAD = 0x0300;                               // set peripheral address to ADC
    DMA0CNT = 0x0003;                               // 4 word transfer
    
    // Set DMA channel 1 for consolle write -------------------------------------
    DMA1CON = 0b0110000000000001;                   // disabled, byte transfer, from DMARAM to periph,
                                                    // post increment, one-shot mode transfer
    DMA1REQ = 0b0000000000001100;                   // auto transfer, transfer to UART1
    DMA1STAH = 0x0000;                              // load DMA buffer address
    DMA1STAL = __builtin_dmaoffset(string);
    DMA1PAD = 0x0224;                               // set peripheral address to UART1
    DMA1CNT = (c_str_l - 1);                        // transfers = CNT + 1
    
    // Set DMA channel 2 for control channel write ------------------------------
    DMA2CON = 0b0110000000000001;                   // disabled, byte transfer, from DMARAM to periph,
                                                    // post increment, one-shot mode transfer
    DMA2REQ = 0b0000000000011111;                   // auto transfer, transfer to UART2
    DMA2STAH = 0x0000;                              // load DMA buffer address
    DMA2STAL = __builtin_dmaoffset(TX_buffer);
    DMA2PAD = 0x0234;                               // set peripheral address to UART2
    
    // Enable ADC and DMA, enable DMA IRQ ---------------------------------------
    AD1CON1bits.ADON = 1;                           // enable ADC
    DMA0_IRQ_CLEAR;
    DMA0CONbits.CHEN = 1;                           // enable DMA
    DMA0_IRQ_ENABLE;
    
    // Set waveform timebase ----------------------------------------------------
    T1CON = 0x0000;									// Timer off, On in ILDE, internal ck,
													// prescaler x1, fin = fosc/2 = 60MHz
    TMR1 = 0x0000;									// clear register
    PR1 = 5958;                             		// get 99.344us timebase
    T1CONbits.TON = ENABLE;							// enable timer
    T1_IRQ_CLEAR;
    T1_IRQ_ENABLE;									// enable timer IRQ
    
    // UART1 consolle -----------------------------------------------------------
    RPINR18 = RPINR18 | 0x002E;                     // assign U1RX to RPI46
    RPOR3 = RPOR3 | 0x0100;                         // assign U1TX to RP41
    U1MODE = 0b0000000000000000;                    // use TX, RX, no flow control, 8 n 1
                                                    // standard mode
    U1STA = 0b0000000100000000;                     // no TX irq, irq on RX char, disable TX
    U1BRG = 389;                                    // set BRG for 9600 baud                         
    U1MODEbits.UARTEN = 1;                          // enable UART1
    
    U1_RX_IRQ_ENABLE;                               // enable RX IRQ
    
    DMA1_IRQ_CLEAR;
    DMA1_IRQ_ENABLE;                                // enable DMA IRQ
    DMA1CONbits.CHEN = 0;                           // disable DMA
    
    // UART2 module communication port ------------------------------------------
    RPINR19 = RPINR19 | 0x0018;                     // assign U2RX to RPI24
    RPOR1 = RPOR1 | 0x0003;                         // assign U2TX to RP36
    U2MODE = 0b0000000000001000;                    // use TX, RX, no flow control, 8 n 1
                                                    // high speed mode
    U2STA = 0b0000000100000000;                     // no TX irq, irq on RX char, disable TX
    U2BRG = 259;                                    // set BRG for 57600 baud
       U2MODEbits.UARTEN = 1;                          // enable UART2
    
    U2_RX_IRQ_ENABLE;                               // enable RX IRQ
    
    DMA2_IRQ_CLEAR;
    DMA2_IRQ_ENABLE;                                // enable DMA IRQ
    DMA2CONbits.CHEN = 0;                           // disable DMA
    
   // init_ic2_400khz();
    init_ic2_100khz();
    
    // SPI Module ---------------------------------------------------------------
   // RPINR22 = RPINR22 | 0x3300;                     // assign SCK to RPI51
   // RPINR22 = RPINR22 | 0x0019;                     // assign MOSI to RPI25
    // RPINR23 = RPINR23 | 0x0022;                     // assign SS to RPI34
    
   
    RPINR22bits.SCK2R = 0b0110011;                     // assign SCK to RPI51
    RPINR22bits.SDI2R = 0b0011001;                     // assign SCK to RPI51
    RPINR23bits.SS2R  = 0b0100010;                     // assign SCK to RPI51

    RPOR0 = RPOR0 | 0x0008;                         // assign MISO to RP20
    
    SPI2BUF = 0x0000;                               // clear SPI buffer
    
    SPI_IRQ_CLEAR;
    SPI_IRQ_DISABLE;
    SPI_IRQ_ENABLE;
    
    SPI2STAT = 0b0000000000000000;                  // disable module, continue operating mode in idle
    SPI2CON1 = 0b0000010110000000;                  // 16bit mode, data changes when CK falls, CK is active high
                                                    // slave mode
    SPI2CON2 = 0b0000000000000000;                  // disable framed mode, disable enhanced buffer
    
    SPI2STATbits.SPIEN = 1;                         // enable peripheral
    
	// interrupts ---------------------------------------------------------------
    INTCON1 = ZERO;                                 // IRQ nesting is enabled
    INTCON2 = ZERO;
    CORCONbits.IPL3 = 0;                            // CPU IRQ priority level is lower than 7
    SR = 0b0000000000100000;                        // set CPU priority level to 1
    IPC23 = (IPC23 & 0x8FFF) | 0x6000;              // set PWM2 IRQ priority level to 6
    IPC1 = (IPC1 & 0xFFF8) | 0x0005;                // set DMA0 IRQ priority level to 5
    IPC0 = (IPC0 & 0x8FFF) | 0x4000;                // set T1 IRQ priority level to 4
    IPC8 = (IPC8 & 0xFF8F) | 0x0040;                // set SPI2 IRQ priority level to 4
    IPC7 = (IPC7 & 0xF8FF) | 0x0300;                // set U2RX IRQ priority level to 3
    IPC6 = (IPC6 & 0xFFF8) | 0x0003;                // set DMA2 IRQ priority level to 3
    IPC3 = (IPC3 & 0xF8FF) | 0x0200;                // set DMA1 IRQ priority level to 2
    IPC2 = (IPC2 & 0x8FFF) | 0x2000;                // set U1RX IRQ priority level to 2    
    
    INTCON2bits.GIE = ENABLE;                       // enable general IRQ    
    
    DDS.PHA = 0x0000;                               // initialize DDS phase accumulator

}

// TIMER1 IRQ - Waveform generation --------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _T1Interrupt(void)
{   // update data_buffer
    
    extern int N_CYCLES;
    
    static int     sign = (int)0x7FFF;
    static int     i = 0; //indica il numero del ciclo
    int index, s_value;
    
    T1_IRQ_CLEAR;
    
    // Waveform generation -------------------------------------------------
    // use DDS architecture to generate a waveform
    if(FLAGS.WV)            //se è accesa la waveform
    {   // waveform is enabled
        if(FLAGS.CYC)
        {   // if cycle-based waveform generation is enabled, load cycle and sweep data
            if(!timer_cycle) //all'inizio il timer è 0 , entra dentro l'if solo se timer_cycle è zero e quindi all'inizio
            {   // end / start of cycle -> load
                if(i >= N_CYCLES)
                {
                    FLAGS.WV_D = 1;                                 // end of cycles -> stop waveform
                                                                    // at next zero crossing
                }
                else if(FLAGS.ZC)
                {   // change cycle parameter at zero crossing
                    timer_cycle = CYCLES[i].time;                   // load cycle length [ms]
                    DDS.M = CYCLES[i].M_val;                        // load initial frequency
                    if(FLAGS.V_L ){
                     //   scale = CYCLES[i].amplitude / 10;                    // load initial amplitude 
                       scale =   __builtin_divud(CYCLES[i].amplitude, (int) 10); //stam divido per 10 per adattare la scala in mV alla massima di 32000 
                    }else{
                        scale = CYCLES[i].amplitude;
                    }
                   
                    i++;
                }
            }

            // update phase accumulator value and waveform scale value, once in a ms
            if(FLAGS.MS)
            {   // one ms elapsed
                FLAGS.MS = 0;

                if((unsigned long)DDS.M < (unsigned long)333333)
                    DDS.M = DDS.M + CYCLES[i-1].M_sweep;

                if((int)scale < (int)0x7FFF)
                    scale = scale + CYCLES[i-1].amp_sweep_float;

                if((int)scale & 0x8000)
                    scale = 0x0000;
            }
        }

        // f = irq call frequency = 10066Hz
        // M = phase increment value
        // n = phase accumulator register n° of bits = 23
        // fresolution = f / 2^n = 1.2mHz
        // fout = M x f / 2^n = 1.2mHz x M

        // Add phase increment value to phase accumulator
        // Don't care about phase accumulator overflows, we are running on a circle...
        DDS.PHA = (unsigned long)DDS.PHA + (unsigned long)(DDS.M);      // update accumulator
        // read 23 bits DDS_table taking the 11 MSbits: 11th bit is the sign, the remaining 10bit are table index
        index = (unsigned int)(((unsigned long)DDS.PHA & 0x007FF000) >> 12);

        // waveform sign identification
        if(index & 0x0400)
        {   // negative
            FLAGS.DS = 1;
            LED2 = ENABLE;
            sign = 0x8000;                          // invert waveform value
        }
        else
        {   // positive
            FLAGS.DS = 0;
            LED2 = DISABLE;
            sign = 0x7FFF;                          // don't invert WVF value
        }

        // zero crossing detector -> stop waveform if required
        if(FLAGS.DS != FLAGS.ODS)
        {   // waveform sign has changed
            FLAGS.ZC = ENABLE;                      // zero crossing flag
            if(FLAGS.WV_D)
            {   // stop waveform generation on next cycle
                FLAGS.WV = 0;
                FLAGS.WV_D = 0;
                DDS.PHA = 0;                        // always start from index 0
                DDS.M = 0;
                scale = _min_scale;
                index = 0;
                i = 0;                              // reset n cycles index
                LED2 = DISABLE;
            }
        }
        else
        {
            FLAGS.ZC = DISABLE;
        }
        FLAGS.ODS = FLAGS.DS;                       // update flags

        if(FLAGS.DC)
        {   // DC mode
            data_buffer = 0x7FFF; //mette al massimo                      // signal out = +1
        }
        else
        {   // AC mode
            
            //s_value = Sine_DDS_table[0x03FF & index];
            //FLAGS.DDS_STATUS=0;
            
            if (FLAGS.CHANGE_DDS) //richiesta di cambiare la tabella dds
            {                           
                switch (FLAGS.DDS_STATUS)
                {
                    case 0:                                                       
                        FLAGS.DDS_STATUS=1;
                        break;
                    case 1:                            
                        FLAGS.DDS_STATUS=2;
                        break;                   
                    case 2:                         
                        FLAGS.DDS_STATUS=3;    
                        break;                  
                    case 3:   
                        FLAGS.DDS_STATUS=4;    
                        break;
                    case 4:   
                        FLAGS.DDS_STATUS=0;    
                        break;    
                }
                FLAGS.CHANGE_DDS = 0;    
            }
            switch (FLAGS.DDS_STATUS)
            {
                  case 0:                
                    s_value = Sine_DDS_table[0x03FF & index];
                    data_buffer = (__builtin_mulss((int)s_value, (int)sign)) >> 15;
                    break;
                  case 1:                
                    s_value = Square_DDS_table[0x03FF & index];
                    data_buffer = (__builtin_mulss((int)s_value, (int)sign)) >> 15;
                    break;
                  case 2:                
                    s_value = Tria_DDS_table[0x03FF & index];
                    data_buffer = (__builtin_mulss((int)s_value, (int)sign)) >> 15;
                    break;
                  case 3:                
                    s_value = Star_DDS_table[0x03FF & index];
                    data_buffer = (__builtin_mulss((int)s_value, (int)sign)) >> 15;
                    break;
                  case 4:                
                    data_buffer = 0x3FFF;
                    break;  
            }           
            // put current value into the data_buffer but scale with volume
            //data_buffer = (__builtin_mulss((int)s_value, (int)sign)) >> 15;
        }
    }
}

// PWM2 IRQ - ADC trigger source -----------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _PWM2Interrupt(void)
{	// system clock
	// called every 40us (25kHz), synchronous with PWM period
    // PWM interrupt is called every TWO PWM cycle!! (PWM cycle works @50kHz) 
    
    // this IRQ launches automatically an ADC conversion, at the end of the conversion
    // (synchronous sample on 4 channels, 2us for channel) a DMA IRQ happens
    
    extern int ov_mon, oi_mon;
    extern unsigned int timer_ov, DEEP_SUPPLY;
    extern unsigned long min_counter;
    extern unsigned long min_on_counter;
    extern unsigned long timer_cycle;      
        
    static int timer_ms = _1ms;
    
    static unsigned int      EN_DIS_DEB = 0x7FFF;               // debounce
    
    PWM_IRQ_CLEAR;                                              // clear IF

    // check interrupt source
    if(PWM_FAULT_IRQ)
    {   // is a fault irq -> disabling irq will also reset irq flag
        // PWM2 and PWM3 pins are already put in safety state for the current cycle by hardware
        PWM_FAULT_DISABLE;
    
        CM4CONbits.CEVT = DISABLE;                              // disable EV bit to allow
                                                                // further event
        
        ERR_FLAGS.DRV = ENABLE;                                 // signal error
        HW_CFG.PEN = DISABLE;                                   // disable power driver and 
        FLAGS.UHW = ENABLE;                                     // update HW configuration
    }
    else
    {   // is a normal pwm interrupt
        // UPDATE SW counters ------------------------------------------------------
        if(TIMER_0)
            TIMER_0--;

        if(TIMER_I2C)
            TIMER_I2C--;

        if(!TIMER_MINUTE--)
        {   // increment minute counter and signal save required
            min_counter++;                                      // power ON time
            if(FLAGS.WV || FLAGS.SPI)
                min_on_counter++;                               // generation ON time

            TIMER_MINUTE = _1min;
            FLAGS.SCM = 1;                                      // save request
        }

    //    if(trs < 0x7FFF)
    //        trs++;                                              // smooth I, V transitions

        if(timer_ov)
            timer_ov--;

        if(ov_mon)
            ov_mon--;

        if(oi_mon)
            oi_mon--;

        if(RX_timeout)
            RX_timeout--;

        if(!timer_ms--)
        {   // ms SW timer ---------------------------------------------------------
            timer_ms = _1ms;                                    // reload timer

            if(timer_cycle)
               timer_cycle--;

            // update DDS waveform parameters
            FLAGS.MS = 1;

            // check undervoltage flag, capture deep supply interval ---------------
            if(FLAGS.UVL != FLAGS.UV) //serve per vedere prima e dopo se è cambiata lo stato di undervoltage
            {   // undervoltage state has changed
                if(FLAGS.UV)
                {   // undervoltage edge -> reset counter now
                    DEEP_SUPPLY = 0;
                    ERR_FLAGS.DIP = 1;
                }
            }
            else if(FLAGS.UV)
            {   // count ms
                if(DEEP_SUPPLY < 0xFFFF)
                    DEEP_SUPPLY++;                              // increase counter up to 65535ms
            }
            FLAGS.UVL = FLAGS.UV;                               // update latch
        }
       
        // Check UART 1 transmission state --------------------------------------
        // this is required for proper DMA initialization
        if(U1STAbits.TRMT)
            U1STAbits.UTXEN = 0;                                // disable TX

    }

    // ENABLE/DISABLE ----------------------------------------------------------
    if(ON_OFF) //è collegato al GPIO3 che è ausiliario, non serve quindi
    {
        if(EN_DIS_DEB < B_lim_up)
        {
            EN_DIS_DEB++;
            if(EN_DIS_DEB > B_thr_up)
                FLAGS.EN = 1;
        }
    }
    else
    {
        if(EN_DIS_DEB > B_lim_dn)
        {
            EN_DIS_DEB--;
            if(EN_DIS_DEB < B_thr_dn)
                FLAGS.EN = 0;
        }
    }
}

// DMA0 IRQ --------------------------------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _DMA0Interrupt(void)
{   // After ADC conversion, the DMA channel transfer data to memory,
    // this routine is called at the end of data transfer
    // new ADC data available on ADC buffer (Y memory)  
    
    extern long Vsum, Isum;
    extern int Vline, VlineV; //vlineV è in volt, Vline è quello in uscita dall'ADC
    extern int V_offset, I_offset,Ilow_offset; //XWB aggiunta calcolo offset ilow
    extern int gain; //usato per compensare la variazione della Vline il ref è Vline a 30V
    extern int max_v, max_i;
    extern struct  {    
        int     IGBT;               // IGBT temperature
        int     BOARD;              // board temperature
        int     TRAFO;              // trafo temperature
        }T;
        
    int abs;
    int data;
    long partial;
   
#ifndef _PID
    int s_ref; // nn viene usata 
#endif
    
    long c_val;
    static int i = 0;
    
    static int dec = _rms_dec;
    static int dec_m = _max_dec;

#ifdef _offset_compensation    
    static int M_pos_i = 0;
    static int M_neg_i = 0;
#endif    
    static int M_diff = 0;
    
    DMA0_IRQ_CLEAR;
         
    
    feedback.V =    ADC.V_CH - V_offset-V_offsetFixed;
    feedback.I =    ADC.I_CH - I_offset-I_offsetFixed;
    feedback.Ilow = ADC.IlowCH-Ilow_offset-Ilow_offsetFixed; 
    
    if(ADC.V_SP & 0x8000) 
    {   // negative
        data = (unsigned int)(ADC.V_SP & 0x7FFF) >> 1;
    }
    else
    {   // positive
        data = (unsigned int)(ADC.V_SP | 0x8000) >> 1;
    }
    
    partial = __builtin_mulss((int)Vline, (int)127);  // partial = Vline * a0
    partial  = (long)(partial) + (int)data;           // Vline = (Vline * a0) + ADC fa una media?
    Vline = partial >> 7; //divide per 128     
    
    if(Vline > _Vl_min)  //se supera il limite inf di 30V deve essere scalato 3050
    {  
        gain = (int)__builtin_divud((long)k0, (int)Vline);   // gain = k0 / Vline        //lo metto un po' più alto per avere margine vicino a 300V, serve per moltiplicare per il guadagno con la virgola
        FLAGS.UV = DISABLE;
    } //l'over voltage è disabilitato  
    else    // limit Vline min value to about 30V
    {   
        gain = _def_gain; //32000
        FLAGS.UV = ENABLE;
    }
    
   // convert Vline in Volts
    partial = __builtin_mulss((int)Vline, (int)_Vl_scale);
    VlineV = partial >> 15;  // is the value in Volts e dovrebbe essere calcolato come Vmis[V]=(Vadc[fraz]>>15)*Vref*AttenPartitore
    
         
     #ifdef _PID
        //SPI + open loop
        if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && !FLAGS.V_L && !FLAGS.I_L && !FLAGS.SCALE )  
        {  
            scaleV = SPI_CONVERSION_VOLTAGE_OPEN_180V;
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = 0;
            PID(&PID_DATA);
            pwm = (__builtin_mulss((int)data_buffer, (int)scaleV) >> 15);   
            c_val = (long)(__builtin_mulss((int)pwm,(int)gain)) >> 15;                
        
        }else if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && !FLAGS.V_L && !FLAGS.I_L  && FLAGS.SCALE )  
        {  
            scaleV = SPI_CONVERSION_VOLTAGE_OPEN_18V;
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = 0;
            PID(&PID_DATA);
            pwm = (__builtin_mulss((int)data_buffer, (int)scaleV) >> 15);   
            c_val = (long)(__builtin_mulss((int)pwm,(int)gain)) >> 15;                      
        }   
        //SPI + controllo tensione scala 180V
        else if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && FLAGS.V_L && !FLAGS.SCALE )  
        {  
            scaleV =  SPI_CONVERSION_VOLTAGE_180V;           // fa in modo cohe aumentando aumenta anche la rispettiva uscita, usato in  openloop
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleV) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain) >> 15); //_PWM_max
        }
         //SPI + controllo tensione scala 18V
        else if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && FLAGS.V_L && FLAGS.SCALE)  
        {  
            scaleV = SPI_CONVERSION_VOLTAGE_18V ;   //la scala deve essere Ration180_18 volte di più della scala normale
            PID_DATA.measuredOutput = feedback.V ;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleV)>>11 ); // ho fatto così perchè il valore da moltimplicare è circa 7 ma per avere risoluzione lo esprimo in in fino a 32676 e lo divido per 2048 così ho max 15
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = (PID_DATA.controlOutput);
            c_val = (long)(__builtin_mulss((int)pwm,(int)_PWM_max) >> 15);           
        }
        //SPI + controllo corrente 7FFF=6Arms scala 25A
        else  if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && FLAGS.I_L && !FLAGS.SCALEI)  
            {  
                scaleI =  SPI_CONVERSION_CURRENT;
                PID_DATA.measuredOutput = feedback.I;
                PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleI) >> 15);
                PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
                PID(&PID_DATA);
                pwm = PID_DATA.controlOutput;          
                c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
         //SPI + controllo corrente 7FFF=6Arms scala 6A
        else  if(FLAGS.SPI && !FLAGS.WV && !FLAGS.DC && FLAGS.I_L && FLAGS.SCALEI) 
            {  
                scaleI =  SPI_CONVERSION_CURRENT_6A;
                PID_DATA.measuredOutput = feedback.Ilow;
                PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleI) >> 14);
                PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
                PID(&PID_DATA);
                pwm = PID_DATA.controlOutput;          
                c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }       
        //DC + controllo tensione    
        else  if(FLAGS.DC && FLAGS.V_L )  
            {  
            data_buffer = 0x7FFF;
            scaleV = __builtin_mulss((int)HW_CFG.VDC, (int)2750);
            PID_DATA.measuredOutput = feedback.V /5 ;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
        //DC e open loop
        else if(FLAGS.DC && !FLAGS.V_L && !FLAGS.I_L)  
            {  
            data_buffer = 0x7FFF;
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = 0;
            PID(&PID_DATA);
            pwm = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);         
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }  
        //DC + controllo corrente    
        else  if(FLAGS.DC && FLAGS.I_L )  
            {          
            data_buffer = 0x7FFF;
            scaleI = scale * CYC_CONVERSION_CURRENT_DC;
            PID_DATA.measuredOutput = feedback.I;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleI) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 14);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
        else if (FLAGS.CYC && !FLAGS.SPI && !FLAGS.DC && FLAGS.V_L && !FLAGS.SCALE )  //cicli e controllo in tensione scala normale
            { 
            scaleV= scale * CYC_CONVERSION_VOLTAGE_VRMS; 
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleV) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
        else if (FLAGS.CYC && !FLAGS.SPI && !FLAGS.DC && FLAGS.V_L && FLAGS.SCALE)  //cicli e controllo in tensione scala sensibile
            { 
            scaleV= scale* CYC_CONVERSION_VOLTAGE_VRMS_HIGH_SENS;
            PID_DATA.measuredOutput =  feedback.V /5;           //gain aggiunto perchè non controlla
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleV) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
            
        else if (FLAGS.CYC && !FLAGS.SPI && !FLAGS.DC && FLAGS.I_L )  //cicli e controllo in corrente
            { 
            scaleI= scale * CYC_CONVERSION_CURRENT_IRMS;
            PID_DATA.measuredOutput = feedback.I;//  feedback.Ilow / 5; // //
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scaleI) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
             pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            } 

        else if (FLAGS.WV && !FLAGS.CYC && FLAGS.SPI  && !FLAGS.DC && FLAGS.V_L && !FLAGS.SCALE) //console e controllo in tensione 180V
            { 
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
        else if (FLAGS.WV && !FLAGS.CYC && FLAGS.SPI  && !FLAGS.DC && FLAGS.V_L && FLAGS.SCALE) //console e controllo in tensione 18V
            { 
            PID_DATA.measuredOutput = feedback.V/5;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }    
        else if (FLAGS.WV && !FLAGS.CYC && FLAGS.SPI  && !FLAGS.DC && FLAGS.I_L ) //console e controllo in corrente
            { 
            PID_DATA.measuredOutput = feedback.I;
            PID_DATA.controlReference = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
            PID_DATA.controlReference = PID_DATA.controlReference - (M_diff);
            PID(&PID_DATA);
            pwm = PID_DATA.controlOutput;          
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
     
        else if (!FLAGS.CYC && FLAGS.SPI  && !FLAGS.DC && FLAGS.O_L ) //console e openloop, ho tolto waveform on perchè oscillava nel passaggio corrente open loop
            { 
            PID_DATA.measuredOutput = feedback.V;
            PID_DATA.controlReference = 0;
            PID(&PID_DATA);
            pwm = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);         
            #ifdef _use_dithering
            // Add dither to improve resolution ----------------------------------------
            pwm = pwm + ((int)n_rand() >> 12);         // add dither prima era 12
            #endif
            c_val = (long)(__builtin_mulss((int)pwm, (int)gain)) >> 15;
            }
            
            else {c_val=0;} // open loop mode
    
    
    #endif
    // 3P3Z controller ---------------------------------------------------------
#ifdef _3P3Z
    // regulate output respect loop mode
    if(FLAGS.I_L)
    {   // close loop on current signal
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);      // scale ref amplitude
        SMPS_Controller3P3ZUpdate(&str_3p3z, (uint16_t *)&feedback.I, s_ref, (uint16_t *)&pwm);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
    else if(FLAGS.V_L)
    {   // close loop on voltage signal
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
        SMPS_Controller3P3ZUpdate(&str_3p3z, (uint16_t *)&feedback.V, s_ref, (uint16_t *)&pwm);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
    else
    {   // open loop mode
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
        SMPS_Controller3P3ZUpdate(&str_3p3z, (uint16_t *)&feedback.V, 0, (uint16_t *)&pwm); // continue to feed controller
        pwm = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
#endif

    // dsp PID controller -------------------------------------------------------
#ifdef _dspPID
    // regulate output respect loop mode
    if(FLAGS.I_L)
    {   // close loop on current signal
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);      // scale ref amplitude
        SMPS_ControllerPIDUpdate(&str_PID, (uint16_t *)&feedback.I, s_ref, (uint16_t *)&pwm);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
    else if(FLAGS.V_L)
    {   // close loop on voltage signal
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
        SMPS_ControllerPIDUpdate(&str_PID, (uint16_t *)&feedback.V, s_ref, (uint16_t *)&pwm);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
    else
    {   // open loop mode
        s_ref = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
        SMPS_ControllerPIDUpdate(&str_PID, (uint16_t *)&feedback.V, 0, (uint16_t *)&pwm); // continue to feed controller
        pwm = (__builtin_mulss((int)data_buffer, (int)scale) >> 15);
//        pwm = (__builtin_mulss((int)pwm, (int)trs) >> 15);
    }
#endif


    // saturate PWM value according to the PWM peripheral dynamic --------------
    // this value is actually lower than +/-600 because the dead time
    // must be take in account
    if(c_val > _PWM_max)
        c_val = _PWM_max;
    if(c_val < _PWM_min)
        c_val = _PWM_min;
    
    // DEBUG -------------------------------------------------------------------
    if(i > 511)
        i = 0;
if (FLAGS.I_L  )
{   v1[i] = PID_DATA.controlReference;
    v2[i] = PID_DATA.measuredOutput;
    v3[i] =  ADC.IlowCH;
    v4[i++] = c_val;
}
if (FLAGS.V_L )
{   v1[i] = PID_DATA.controlReference;
    v2[i] = PID_DATA.measuredOutput;
    v3[i] =  data_buffer;
    v4[i++] = c_val; 
}
    
#ifdef _3P3Z
    vr[i] = feedback.V;
    vo[i] = feedback.I;
    vp[i] = c_val;    
    vc[i++] = s_ref; 
#endif

#ifdef _dspPID
    vr[i] = feedback.V;
    vo[i] = feedback.I;
    vp[i] = c_val;    
    vc[i++] = s_ref;
#endif
    // END DEBUG ---------------------------------------------------------------

    // add offset to convert to a positive scale    
    pwm = (int)c_val+ PWM_mid_duty ;

    
    switch (set_PWM)
    {
        case 0:              
            npwm =   PWM_max_duty - pwm-2; //  npwm receives complementary duty in center aligned mode                   
            PDC2 = pwm;
            PDC3 = npwm; 
            break;
        case 1:
        case 2:    
            npwm = pwm;                 // npwm receives the same duty value
            PDC2 = pwm;
            PDC3 = npwm;
            break;
        case 3:
            PDC2 = pwm;
            break;
    }   
    

    // update PWM registers
    //PDC3 = npwm;                // PWM CH3 is the negative out terminal
   // PDC2 = pwm;                 // PWM CH2 is the positive out terminal
    // END of section moved ----------------------------------------------------
    
    // RMS values --------------------------------------------------------------
    if(!dec--)
    {   // samples decimation
        dec = _rms_dec;
                
        // Compute rms partial values
        data = ADC.V_CH - V_offset;
        partial = __builtin_mulss((int)data, (int)data);                    // partial = V^2
        partial = partial >> 7;                                             // resize to 25bit

        Vsum = partial + ((long)(Vsum >> 7) * (int)127);                     // partial = V^2 + Vsum * a0

        data = ADC.I_CH - I_offset;
        partial = __builtin_mulss((int)data, (int)data);                    // partial = V^2
        partial = partial >> 7;                                             // resize to 25bit

        Isum = partial + ((long)(Isum >> 7) * (int)127);                     // partial = V^2 + Vsum * a0
    }
            
    // Filter Trafo temperature ------------------------------------------------
    // convert to to unipolar scale (0 - 32768)
    // range is halved to maintain fractional mpy compatibility
    //XWB devo mettere una lettura fittizia 0x1234 della temperatura trafo perchè non è ancora implementata, al posto ci andava adc.ttmp
    if(0x1234 & 0x8000) 
    {   // negative
        data = (unsigned int)(0x1234 & 0x7FFF) >> 1;
    }
    else
    {   // positive
        data = (unsigned int)(0x1234 | 0x8000) >> 1;
    }
    // check ranges, it's not possible to detect NTC disconnection!!
    if(data < min_NTC)
        ERR_FLAGS.NTC = 1;
    else
        ERR_FLAGS.NTC = 0;
    // temp is quite linear between 25 and 125°C with Rup = 1.2kohm
    // ADC voltage @ 25°C = 2.94V (ADC code: 32111)
    // ADC voltage @ 125°C = 0.731V (ADC code: 7984)
    // linear approximation gives: Vadc[V] = -0.02215 * T[°C] + 3.5
    // inversion and scaling with ADC maximum code (32767) gives:
    // T[°C] = 158 - ADCcode * 0.004135
    partial = __builtin_mulss((int)data, (int)s_NTC);                       // partial = data * (-0.004135 * 32768)
    data = (int)((partial >> 15) + o_NTC);                                  // data = data * s_NTC + o_NTC
    // filter out data
    partial = __builtin_mulss((int)T.TRAFO, (int)3);                       // partial = TrafoT * a1
    partial  = (long)(partial) + (int)data;                                 // TrafoT = (TrafoT * a1) + ADC
    T.TRAFO = partial >> 2;
    
    // V, I over range control -------------------------------------------------
    // Check max voltage -------------------------------------------------------
    // extract absolute value
    if(feedback.V > 0)
        if(FLAGS.SCALE)(abs = feedback.V/Ratio180_18);  // se uso la scala 18V devo scalare il valore di tensione in uscita, abs, del guadagno delle scale per avere la lettura in tensione corretta
        else (abs = feedback.V);
    else
        if(FLAGS.SCALE)(abs = -(feedback.V/Ratio180_18));
        else (abs = -feedback.V);
    
    // extract max value in time from abs value
    if(abs > max_v)
    {   // capture the peak
        max_v = abs;
    }
    else
    {   // let max_v decay with time
        if(!dec_m)
        {   // max_v = max_v * 0.976
            max_v = (__builtin_mulss((int)max_v, (int)32000) >> 15);
        }
    }
    
    // check instantaneous value
    if(abs > limit.V)
        FLAGS.ORV = ENABLE;             // signal over voltage
#ifdef _auto_overrange_ctrl
    else if(abs < limit.nV)
        FLAGS.ORV = DISABLE;            // clear signaling if the instantaneous value
                                        // drops under low hysteresis limit
#endif
    if(abs > limit.VS)
    {   // now instantaneous value is over max value + 50% -> stop immediately waveform
        FLAGS.WV_D = ENABLE;            // stop wave request
        ERR_FLAGS.SO = ENABLE;          // stop wave
        FLAGS.V_L = DISABLE;            // open loop mode
        FLAGS.I_L = DISABLE;
        FLAGS.O_L = ENABLE;
        scale = _min_scale;
    }
        
        
    // Check max current -------------------------------------------------------
    // extract absolute value
    if(feedback.I > 0)
        abs = feedback.I;
    else
        abs = -feedback.I;
    
    // extract max value in time from abs value
    if(abs > max_i)
    {   // capture the peak
        max_i = abs;
    }
    else
    {   // let max_i decay with time
        if(!dec_m)
        {   // max_i = max_i * 0.976
            max_i = (__builtin_mulss((int)max_i, (int)32000) >> 15);
        }
    }
    
    // check instantaneous value
    if(abs > limit.I)
        FLAGS.ORI = ENABLE;             // signal over current
#ifdef _auto_overrange_ctrl
    else if(abs < limit.nI)
        FLAGS.ORI = DISABLE;            // clear signalling if the instantaneous value
                                        // drops under low hysteresis limit
#endif    

    if(abs > limit.IS)
    {   // now instantaneous value is over max value + 50% -> stop immediately waveform
        FLAGS.WV_D = ENABLE;            // stop wave request
        ERR_FLAGS.SO = ENABLE;          // stop wave
        FLAGS.V_L = DISABLE;            // open loop mode
        FLAGS.I_L = DISABLE;
        FLAGS.O_L = ENABLE;
        scale = _min_scale;
    }

#ifdef _offset_compensation
    // Extract max and min peak current value ----------------------------------
    if((int)feedback.I > (int)M_pos_i)
    {
        partial = __builtin_mulss((int)M_pos_i, (int)24575);
        partial = partial + __builtin_mulss((int)feedback.I, (int)8191);
        M_pos_i = partial >> 15;
//        M_pos_i = feedback.I;
    }
    else
    {   // let value decay with time
        if(!dec_m)
        {   // value = value * 0.976
            M_pos_i = (__builtin_mulss((int)M_pos_i, (int)32000) >> 15);
        }
    }
    
    if((int)feedback.I < (int)M_neg_i)
    {
        partial = __builtin_mulss((int)M_neg_i, (int)24575);
        partial = partial + __builtin_mulss((int)feedback.I, (int)8191);
        M_neg_i = partial >> 15;
//        M_neg_i = feedback.V;
    }
    else
    {   // let value decay with time
        if(!dec_m)
        {   // value = value * 0.976
            M_neg_i = (__builtin_mulss((int)M_neg_i, (int)32000) >> 15);
        }
    }
    
    // M_diff = M_pos_i - (-M_neg_i)
    // if M_diff > 0 -> |positive current peak| is > than |negative current peak|
    // if M_diff < 0 -> |positive current peak| is < than |negative current peak|
    // use this value as error to control DC bridge bias
    if(FLAGS.WV && FLAGS.V_L && !FLAGS.DC)
        M_diff = (M_pos_i + M_neg_i) >> 4;  // only in voltage mode, but not DC
    else
        M_diff = 0;
    
    //M_diff = M_pos_i + M_neg_i;
    if(M_diff > _max_i_diff)
        M_diff = _max_i_diff;
    if(M_diff < _min_i_diff)
        M_diff = _min_i_diff;
#else
    M_diff = 0;
#endif    
    
    // decrement and reload peak decay decimator -------------------------------
    if(!dec_m--)
        dec_m = _max_dec;
}

// DMA1 IRQ --------------------------------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _DMA1Interrupt(void)
{   // routine called at the end of memory to UART data transmission
    // buffer transmitted
    DMA1_IRQ_CLEAR;
    
    DMA1CONbits.CHEN = 0;                           // disable DMA
}

// DMA2 IRQ --------------------------------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _DMA2Interrupt(void)
{   // routine called at the end of memory to UART data transmission
    // buffer transmitted
    DMA2_IRQ_CLEAR;
    
    DMA2CONbits.CHEN = 0;                           // disable DMA
 }

// SPI2 IRQ --------------------------------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _SPI2Interrupt(void)
{   // routine called when a new sample is ready in the SPI2 Buffer
    SPI_IRQ_CLEAR;
    temp_SPI= SPI2BUF;
    
       if(!FLAGS.CYC) //   cambiato il 07/04/19 perchè non parte da spi e riempie il buffere e non vede più l'interrupt (!FLAGS.WV && FLAGS.SPI)
       {
        data_buffer = temp_SPI;                        // load raw data only if no waveform active
                                                       // and SPI mode selected        
        SPI2BUF = 0xA5A5;                               // reply with dummy data
       }
}

// UART1 RX IRQ ----------------------------------------------------------------
void __attribute__((__interrupt__, auto_psv)) _U1RXInterrupt(void)
{   // char received on consolle
    extern int STATE_MACHINE;
    extern char char_buffer;
    extern float scale;
    extern struct CFG_type HW_CFG;
    
    U1_RX_IRQ_CLEAR;
    
    char_buffer = U1RXREG;                          // read data
        
    switch(char_buffer)
    {
        /* case '1':                                   // decrease wave amplitude   
             init_ic2_100khz();
            stam_rele_on();
            init_ic2_400khz();
          break;
        case '2':                                   // decrease wave amplitude      
            init_ic2_100khz();
            stam_rele_off();
            init_ic2_400khz();
            break;
        case '3':                                   // decrease wave amplitude 
            init_ic2_100khz();
            stam_rele_read();
            init_ic2_400khz();
          break;*/
        case '-':                                   // decrease wave amplitude      
            if(FLAGS.WV)
            {
                if(FLAGS.DC)
                {
                    if(scale > _min_dc_scale)
                        scale = scale - _scale_step; //scale step 100
                }
                else
                {
                    if(scale > _min_scale)
                        scale = scale - _scale_step;
                }
            }
            break;
        case '+':                                   // increase wave amplitude
            if(FLAGS.WV)
            {
                if(scale < _max_scale)
                    scale = scale + _scale_step;
            }
            break;
            
        case '_':                                   // decrease wave amplitude shift - big step
            if(FLAGS.WV)
            {
                if(FLAGS.DC)
                {
                    if(scale > _min_dc_scale)
                        scale = scale - _scale_step_big; //scale step 100
                }
                else
                {
                    if(scale > _min_scale){
                        scale = scale - _scale_step_big;
                      //  sprintf(string,"\n\r|scale =%d |pwm= %d |npwm=%d |\n\r\n ", scale, pwm, npwm);
                       // send_text( string );
                    // sprintf(string,"|PDC3=%d |PDC2=%d                   \n", PDC3, PDC2);
                     //send_text( string );
                    }
                }
            }
            break;
        case '*':                                   // increase  wave amplitude shift + big step
            if(FLAGS.WV)
            {
                if(scale < _max_scale){
                    scale = scale + _scale_step_big;
                   // sprintf(string,"\n\r|scale =%d |pwm= %d |npwm=%d |\n\r\n", scale, pwm, npwm);
                    // send_text( string );
                     //sprintf(string,"|PDC3=%d |PDC2=%d                   \n", PDC3, PDC2);
                     //send_text( string );
                }
            }
            break;
            
        case ',':                                   // decrease frequency (-1Hz)
            if(FLAGS.WV)
            {
                if(DDS.M > _min_freq)
                    DDS.M = DDS.M - _freq_step;
            }
            break;
        case '.':                                   // increase frequency (+1Hz)
            if(FLAGS.WV)
            {
                if(DDS.M < _max_freq)
                    DDS.M = DDS.M + _freq_step;
            }
            break;
        case 'U':                                   // toggle rms or peak
            FLAGS.RMS = !FLAGS.RMS;
            break;
        case 'E':                                   // reset error flag
            send_text(" ERRORS CLEARED                       \r\n");
            ERR_FLAGS.SO = DISABLE;
            ERR_FLAGS.DRV = DISABLE;
            ERR_FLAGS.MTI = DISABLE;
            PWM_FAULT_ENABLE;
            FLAGS.V_L = DISABLE;
            FLAGS.I_L = DISABLE;
            FLAGS.O_L = ENABLE;
            scale = _min_scale;
            break;
        case 'A':                                   // print actual PID coefficients
            if(!FLAGS.WV)
        #ifdef _PID
                send_coeff(pid_coeff);
        #endif
            break;
        case 'T':                                   // print actual limit values
            if(!FLAGS.WV)
                send_limit();
            break;
        case 'L':                                   // read a new V or I limit
            if(!FLAGS.WV)
                STATE_MACHINE = OR_IN;
            break;
        case 'K':                                   // read a new coefficient
            if(!FLAGS.WV)
                STATE_MACHINE = K_IN;
            break;
        case 'C':                                   // calibrate offset
            if(!FLAGS.WV)
                STATE_MACHINE = OFF_CAL;
            break;
        case 'W':     
            if ( HW_CFG.PEN){
                // toggle waveform ON/OFF
                if(!ERR_FLAGS.SO)
                {   // no error
                    if(!FLAGS.WV)
                    {   // start waveform setting DDS generator to 50Hz
                        FLAGS.WV = ENABLE;
                        FLAGS.ZC = ENABLE;
                        DDS.PHA = 0;
                        DDS.M = _f50Hz;
                        scale = _min_scale;
                        send_text("\r\n WAVEFORM ON                        \r\n");
                    }
                    else if(FLAGS.WV)
                    {   // stop waveform but when reaches 0
                        FLAGS.WV_D = ENABLE;
                        send_text("\r\n WAVEFORM OFF                       \r\n");
                        // reset overcurrent flags
                        FLAGS.ORI = DISABLE;
                        FLAGS.ORV = DISABLE;
                    }
                }
            }else{
                 send_text("\r\n ERROR #1  POWER IS OFF             \r\n");
            }
            break;
        case 'O':                                   // open loop mode
            send_text("\r\n OPEN LOOP MODE                     \r\n");
            FLAGS.V_L = DISABLE;
            FLAGS.I_L = DISABLE;
            FLAGS.O_L = ENABLE;
            HW_CFG.OL = ENABLE;
            HW_CFG.IL = DISABLE;
            HW_CFG.IAC = DISABLE;
            HW_CFG.IDC = DISABLE;
            HW_CFG.VL = DISABLE;
            HW_CFG.VAC = DISABLE;
            HW_CFG.VDC = DISABLE;
            
            scale = _min_scale;
            break;
        case 'V':                                   // voltage mode
            if(!FLAGS.I_L)
            {
                FLAGS.V_L = ENABLE;
                FLAGS.I_L = DISABLE;
                FLAGS.O_L = DISABLE;
                HW_CFG.OL = DISABLE;
                HW_CFG.IL = DISABLE;
                HW_CFG.IAC = DISABLE;
                HW_CFG.IDC = DISABLE;
                HW_CFG.VL = ENABLE;
                HW_CFG.VAC = DISABLE;
                HW_CFG.VDC = DISABLE;
                scale = _min_scale;
            #ifdef _PID
                cfg_PID();                          // configure PID controller
                                                    // and load coefficients
            #endif
            #ifdef _3P3Z
                cfg_3P3Z();                         // configure 3P3Z controller
                                                    // and load coefficients
            #endif
            #ifdef _dspPID
                cfg_dspPID();                       // configure dspPID controller
                                                    // and load coefficients
            #endif
                send_text("\r\n VOLTAGE MODE                       \r\n");
            }
            break;
        case 'I':                                   // current mode
            if(!FLAGS.V_L)
            {
                FLAGS.V_L = DISABLE;
                FLAGS.I_L = ENABLE;
                FLAGS.O_L = DISABLE;
                HW_CFG.OL = DISABLE;
                HW_CFG.IL = ENABLE;
                HW_CFG.IAC = DISABLE;
                HW_CFG.IDC = DISABLE;
                HW_CFG.VL = DISABLE;
                HW_CFG.VAC = DISABLE;
                HW_CFG.VDC = DISABLE;
                scale = _min_scale;
            #ifdef _PID
                cfg_PID();                          // configure PID controller
                                                    // and load coefficients
            #endif
            #ifdef _3P3Z
                cfg_3P3Z();                         // configure 3P3Z controller
                                                    // and load coefficients
            #endif
            #ifdef _dspPID
                cfg_dspPID();                       // configure dspPID controller
                                                    // and load coefficients
            #endif
                send_text("\r\n CURRENT MODE                       \r\n");
            }
            break;
        case 'S':                                   // set serial number
            if(!FLAGS.WV)
                STATE_MACHINE = SERIAL_SET;
            break;
        case 'M':                                   // set manufacturer code
            if(!FLAGS.WV)
                STATE_MACHINE = MAN_SET;
            break;
        case 'D':                                   // send board data
            if(!FLAGS.WV)
                STATE_MACHINE = BRD_DATA;
            break;
        case 'P':                                   // enable/disable power drivers
            if(!FLAGS.WV)
            {
                if(HW_CFG.PEN)
                {   // put driver off
                    HW_CFG.PEN = DISABLE;
                    FLAGS.UHW = ENABLE;             // update HW configuration
                    send_text("\r\n POWER OFF                          \r\n");
                }
                else
                {   // put driver on
                    HW_CFG.PEN = ENABLE;
                    FLAGS.UHW = ENABLE;             // update HW configuration
                    send_text("\r\n POWER ON                           \r\n");
                }
            }
            break;
               /*STAM modification init SPI mode START*/
        case 'X':      
  
            if(!FLAGS.WV)
            {
                if( HW_CFG.URT ){
                    //uart attiva! la disattivo e sul main sarà attivata la SPI
                    HW_CFG.URT = DISABLE; // perchè è il 14 bit di HW_general=0 è attiva la spi,1 la seriale 
                    FLAGS.SPI = 1;          // messo il 08/04/19 perchè con la console non si attiva la spi
                    FLAGS.UHW = ENABLE;             // update HW configuration
                    //HW_CFG.PEN= ENABLE; //devo abilitarlo altrimenti perdo il controllo 
                    send_text("\r\n *********** SPI ACTIVATED ******* \r\n"); 
                } else {
                        HW_CFG.URT = ENABLE;       //LOGICA NEGATA HW_CFG.URT = ENABLE; DISABILITA LA UART E ABILITA SPI
                        FLAGS.SPI= 0; // messo il 08/04/19 perchè con la console non si attiva la spi
                        FLAGS.UHW = ENABLE;             // update HW configuration                   
                        send_text("\r\n *********** SPI DEACTIVATED ***** \r\n");
                }
            }else{
                send_text("\r\n SPI IS OFF -  Switch off Waveform before\r\n");
            }
            break;
            // modification init SPI mode END*/      
        case 'Z':                                   // change AC to DC waveform
            if(!FLAGS.WV)
            {
                FLAGS.DC = ~FLAGS.DC;    //toggle cambia stato ogni b
              
                if(FLAGS.DC)
                {    
                    send_text("\r\n DC MODE                            \r\n");                   
                    FLAGS.O_L = DISABLE;                 
                    FLAGS.V_L = ENABLE;
                    cfg_PID();
                }
                else
                    send_text("\r\n AC MODE                            \r\n");
            }
            break;
            case 'R':                                   // set serial number
                    //send_text("\r\n STAM TABULA RASA            \r\n");
                asm ("RESET");
            break;
        case 'Q': //XWB
            if(!FLAGS.WV)
            {
                   //abilito con chimata I2C
               init_ic2_100khz();
               VscaleEN(1);
               FLAGS.SCALE = 1;
               send_text("\r\n HIGH SENSITIVITY SCALE             \r\n");               
            }
            break;
                   
        case 'F': //XWB
            if(!FLAGS.WV)
            {
                   //abilito con chimata I2C
               init_ic2_100khz();
               VscaleEN(0);
               FLAGS.SCALE = 0;
               send_text("\r\n STD SCALE                          \r\n");
            }
            break;
                // comandi da console
           case 'B': //XWB
            FLAGS.CHANGE_DDS = 1;
            if(FLAGS.DDS_STATUS==0) //occhio che prende il flag precedente, ordine sfalsato perchè prima visualizza poi cambia
            {
               //FLAGS.CHANGE_DDS = 1;
               send_text("\r\n SQUARE                            \r\n");
            }
            else if (FLAGS.DDS_STATUS==1)
            {
               //FLAGS.CHANGE_DDS = 0;
               send_text("\r\n TRIA                              \r\n");
            }
            else if (FLAGS.DDS_STATUS==2)
            {
               //FLAGS.CHANGE_DDS = 0;
               send_text("\r\n STAR                              \r\n");
            }
            else if (FLAGS.DDS_STATUS==3)
            {
               //FLAGS.CHANGE_DDS = 0;
               send_text("\r\n MANUAL                            \r\n");
            }
            else if (FLAGS.DDS_STATUS==4)
            {
               //FLAGS.CHANGE_DDS = 0;
               send_text("\r\n SINE                              \r\n");
            }
            break;
          case 'N':
            if(set_PWM==0)
            {
                set_PWM=1;
                send_text("\r\n complementary 50kHz              \r\n");        
            }
            else if(set_PWM == 1)
            {
                set_PWM=2;
                send_text("\r\n complementary 100kHz             \r\n");
            }
            else if(set_PWM == 2)
            {
                set_PWM=3;
                send_text("\r\n puh-pull                         \r\n");
            }
            else if(set_PWM == 3)
            {
                set_PWM=0;
                send_text("\r\n 3 Level                          \r\n");
            }         
            cfg_PWM(set_PWM);    
            //FLAGS.O_L = ENABLE;                 // set open loop mode as default
            //HW_CFG.OL = ENABLE;                 //perchè due settaggi?          
            break;    
        default:
            FLAGS.CHR = ENABLE;
            break;
    }
}

// Configure PID controller ----------------------------------------------------
#ifdef _PID
void cfg_PID(void)
{
    extern int pid_coeff[3];
    
    PID_DATA.abcCoefficients = &abc_coeff[0];           // load abc_coeff address to structure
    PID_DATA.controlHistory = &ctrl_hyst[0];            // load samples structure address
    
    if(FLAGS.I_L)
    {   // load current loop coefficients
        pid_coeff[0] = pid_I_coeff[0];                  // Kp
        pid_coeff[1] = pid_I_coeff[1];                  // Ki
        pid_coeff[2] = pid_I_coeff[2];                  // Kd
    }
    else if (FLAGS.SCALE)
    {   // load voltage mode coefficients - default values
        pid_coeff[0] = pid_V_18Vcoeff[0];                  // Kp
        pid_coeff[1] = pid_V_18Vcoeff[1];                  // Ki
        pid_coeff[2] = pid_V_18Vcoeff[2];                  // Kd
    }
    else
    {   // load voltage mode coefficients - default values
        pid_coeff[0] = pid_V_coeff[0];                  // Kp
        pid_coeff[1] = pid_V_coeff[1];                  // Ki
        pid_coeff[2] = pid_V_coeff[2];                  // Kd
    }    
    // clear data structure
    PIDInit(&PID_DATA);    
    PIDCoeffCalc(&pid_coeff[0], &PID_DATA);             // initialize struct with a, b, c coeff.
        
       
    
    // load limit values
    limit.V = _v_limit;                             // load voltage limit
#ifdef _zero
    limit.nV = 50;
#else
    limit.nV = limit.V - (limit.V >> 5);            // add 3% hysteresis
#endif
    if(limit.V > max_V_limit)
        limit.VS = max_VS;                          // shutdown limit = max
    else
        limit.VS = _v_limit ; // mod 07/10 + (_v_limit >> 1);      // shutdown limit = limit * 1.5
    
    limit.I = _i_limit;                             // load current limit
#ifdef _zero
    limit.nI = 50;
#else
    limit.nI = limit.I - (limit.I >> 5);            // add 3% hysteresis
#endif
    if(limit.I > max_I_limit)
        limit.IS = max_IS;                          // shutdown limit = max
    else
        limit.IS = _i_limit + (_i_limit >> 1);      // shutdown limit = limit * 1.5
    
    gain = _def_gain;
}
#endif
    
// Configure 3P3Z controller ---------------------------------------------------
#ifdef _3P3Z
void cfg_3P3Z(void)
{
    // initialize coefficients
    if(FLAGS.I_L)
    {   // load current loop coefficients
        A_coeff[0] = _Ia0;
        A_coeff[1] = _Ia1;
        A_coeff[2] = _Ia2;

        B_coeff[0] = _Ib0;
        B_coeff[1] = _Ib1;
        B_coeff[2] = _Ib2;
        B_coeff[3] = _Ib3;

        // initialize data pointers
        str_3p3z.aCoefficients = &A_coeff[0];
        str_3p3z.bCoefficients = &B_coeff[0];
        str_3p3z.controlHistory = &ctrl_hist[0];
        str_3p3z.errorHistory = &ctrl_err[0];

        // output saturation
        str_3p3z.maxOutput = 32000;
        str_3p3z.minOutput = -32000;

        // normalization
        str_3p3z.postScaler = _IpScaler;
        str_3p3z.preShift = _IpreS;
        str_3p3z.postShift = _IpostS;
    }
    else
    {   // load voltage mode coefficients - default values
        A_coeff[0] = _Va0;
        A_coeff[1] = _Va1;
        A_coeff[2] = _Va2;

        B_coeff[0] = _Vb0;
        B_coeff[1] = _Vb1;
        B_coeff[2] = _Vb2;
        B_coeff[3] = _Vb3;

        // initialize data pointers
        str_3p3z.aCoefficients = &A_coeff[0];
        str_3p3z.bCoefficients = &B_coeff[0];
        str_3p3z.controlHistory = &ctrl_hist[0];
        str_3p3z.errorHistory = &ctrl_err[0];

        // output saturation
        str_3p3z.maxOutput = 32000;
        str_3p3z.minOutput = -32000;

        // normalization
        str_3p3z.postScaler = _VpScaler;
        str_3p3z.preShift = _VpreS;
        str_3p3z.postShift = _VpostS;
    }
    
    // initialize history
    SMPS_Controller3P3ZInitialize(&str_3p3z);
    
    // load limit values
    limit.V = _v_limit;                             // load voltage limit
#ifdef _zero
    limit.nV = 50;
#else
    limit.nV = limit.V - (limit.V >> 5);            // add 3% hysteresis
#endif
    if(limit.V > max_V_limit)
        limit.VS = max_VS;                          // shutdown limit = max
    else
        limit.VS = _v_limit + (_v_limit >> 1);      // shutdown limit = limit * 1.5
    
    limit.I = _i_limit;                             // load current limit
#ifdef _zero
    limit.nI = 50;
#else
    limit.nI = limit.I - (limit.I >> 5);            // add 3% hysteresis
#endif
    if(limit.I > max_I_limit)
        limit.IS = max_IS;                          // shutdown limit = max
    else
        limit.IS = _i_limit + (_i_limit >> 1);      // shutdown limit = limit * 1.5
    
    gain = _def_gain;
}
#endif

// Configure dsp PID controller -------------------------------------------------
#ifdef _dspPID
void cfg_dspPID(void)
{
    // initialize coefficients
    if(FLAGS.I_L)
    {   // load current loop coefficients
        ABC_coeff[0] = _kai;
        ABC_coeff[1] = _kbi;
        ABC_coeff[2] = _kci;

        // initialize data pointers
        str_PID.abcCoefficients = &ABC_coeff[0];
        str_PID.errorHistory = &ctrl_err[0];

        // output saturation
        str_PID.maxOutput = 32000;
        str_PID.minOutput = -32000;

        // normalization
        str_PID.postScaler = _poSi;
        str_PID.preShift = _prShi;
        str_PID.postShift = _poShi;
    }
    else
    {   // load voltage mode coefficients - default values
        ABC_coeff[0] = _kav;
        ABC_coeff[1] = _kbv;
        ABC_coeff[2] = _kcv;

        // initialize data pointers
        str_PID.abcCoefficients = &ABC_coeff[0];
        str_PID.errorHistory = &ctrl_err[0];

        // output saturation
        str_PID.maxOutput = 32000;
        str_PID.minOutput = -32000;

        // normalization
        str_PID.postScaler = _poSv;
        str_PID.preShift = _prShv;
        str_PID.postShift = _poShv;
    }
    
    // initialize history
    SMPS_ControllerPIDInitialize(&str_PID);
    
    // load limit values
    limit.V = _v_limit;                             // load voltage limit
#ifdef _zero
    limit.nV = 50;
#else
    limit.nV = limit.V - (limit.V >> 5);            // add 3% hysteresis
#endif
    if(limit.V > max_V_limit)
        limit.VS = max_VS;                          // shutdown limit = max
    else
        limit.VS = _v_limit + (_v_limit >> 1);      // shutdown limit = limit * 1.5
    
    limit.I = _i_limit;                             // load current limit
#ifdef _zero
    limit.nI = 50;
#else
    limit.nI = limit.I - (limit.I >> 5);            // add 3% hysteresis
#endif
    if(limit.I > max_I_limit)
        limit.IS = max_IS;                          // shutdown limit = max
    else
        limit.IS = _i_limit + (_i_limit >> 1);      // shutdown limit = limit * 1.5
    
    gain = _def_gain;
}
#endif

// OFFSET CALIBRATION ----------------------------------------------------------
int offset_cal(void)
{   // close input relays and read zero values
    // use these values to create a zero reference for AD conversion
    static int  STATE_FUNC = 0;
    
    extern int V_offset, I_offset,Ilow_offset; //XWB aggiunto per tener conto dell'offset della corrente ilow
    static long sum,sum1; //WXB aggiunto sum1 per fare contemporaneamente anche il calcolo con la corrente low
    static int i = 0;
    
    switch(STATE_FUNC)
    {
        case 0:
            if(!FLAGS.WV)
            {   // only if not currently waveform ON
                //CAL_V = ENABLE;
                //CAL_I = ENABLE;
                TIMER_0 = _500ms;
                sprintf(string, "\r\n\n CALIBRATING Voltage...            \r\n"); 
                send_text_stam(string, sizeof(string));
                //send_text("\r\n\n CALIBRATING Voltage...            \r\n");
                STATE_FUNC++;
            }
            break;
        case 1:
            if(!TIMER_0)
            {   // acquire and sum 32768 samples of ADC.V_CH
                // then divide the sum by 32768
                i = 32767;
                sum = 0;
                sum1 =0;        //XWB
                STATE_FUNC++;
            }
            break;
        case 2:
            if(!i--)
            {   // save voltage offset and go to calibrate current 
                V_offset = (int)(sum >> 15);
                
                sum = 0;
                i = 32767;
                sprintf(string, " CALIBRATING Dual Current...          \r\n"); 
                send_text_stam(string, sizeof(string));
              //  send_text(" CALIBRATING Dual Current...          \r\n"); //XWB aggiunta la lettura della corrente
                
                //CAL_V = DISABLE;
                //CAL_I = DISABLE;
                STATE_FUNC++;
            }
            else
            {   // acquire and add samples
                sum = sum + ADC.V_CH-V_offsetFixed;
            }
            break;
        case 3:
            if(!i--)
            {   // save current offset and exit 
                I_offset = (int)(sum >> 15);
                Ilow_offset = (int)(sum1 >> 15); //XWB mi serve per misura loffset della Ilow
                // check if offset values is acceptable
                if((int)V_offset > (int)max_offset)
                    ERR_FLAGS.OFF = 1;
                if((int)V_offset < (int)max_noffset)
                    ERR_FLAGS.OFF = 1;
                
                send_text(" DONE!                                \r\n");
                
                CAL_V = DISABLE;
                CAL_I = DISABLE;
                FLAGS.CAL = ENABLE;
                STATE_FUNC = END_FUNC;
            }
            else
            {   // acquire and add samples
                sum = sum + ADC.I_CH-I_offsetFixed;
                sum1 = sum1 +ADC.IlowCH-Ilow_offsetFixed;
            }
            break;
    }
    
    return (STATE_FUNC);
}

int offset_cal_blocking(void)
{   // close input relays and read zero values
    // use these values to create a zero reference for AD conversion
    static int  STATE_FUNC = 0;
    
    extern int V_offset, I_offset,Ilow_offset; //XWB aggiunto per tener conto dell'offset della corrente ilow
    static long sum,sum1; //WXB aggiunto sum1 per fare contemporaneamente anche il calcolo con la corrente low
    static int i = 0;
    while (STATE_FUNC != 100 ){
    switch(STATE_FUNC)
    {
        case 0:
            if(!FLAGS.WV)
            {   // only if not currently waveform ON
                //CAL_V = ENABLE;
                //CAL_I = ENABLE;
                //TIMER_0 = _500ms;
                sprintf(string, "\r\n CALIBRATING Voltage...            \r\n"); 
                send_text_stam(string, sizeof(string));
                STATE_FUNC++;
            }
            break;
        case 1:
              // acquire and sum 32768 samples of ADC.V_CH
                // then divide the sum by 32768
                i = 32767;
                sum = 0;
                sum1 =0;        //XWB
                STATE_FUNC++;
           
            break;
        case 2:
            if(!i--)
            {   // save voltage offset and go to calibrate current 
                V_offset = (int)(sum >> 15);
                
                sum = 0;
                i = 32767;
                sprintf(string, " CALIBRATING Dual Current...          \r\n"); 
                send_text_stam(string, sizeof(string));
                
                //CAL_V = DISABLE;
                //CAL_I = DISABLE;
                STATE_FUNC++;
            }
            else
            {   // acquire and add samples
                sum = sum + ADC.V_CH;
            }
            break;
        case 3:
            if(!i--)
            {   // save current offset and exit 
                I_offset = (int)(sum >> 15);
                Ilow_offset = (int)(sum1 >> 15); //XWB mi serve per misura loffset della Ilow
                // check if offset values is acceptable
                if((int)V_offset > (int)max_offset)
                    ERR_FLAGS.OFF = 1;
                if((int)V_offset < (int)max_noffset)
                    ERR_FLAGS.OFF = 1;
                
                send_text(" DONE!                                \r\n");
                
                CAL_V = DISABLE;
                CAL_I = DISABLE;
                FLAGS.CAL = ENABLE;
                STATE_FUNC = 100;
            }
            else
            {   // acquire and add samples
                sum = sum + ADC.I_CH;
                sum1 = sum1 +ADC.IlowCH;
            }
            break;
        }
    
        TIMER_0 = _40us;
        while(TIMER_0);   
    
    }
    STATE_FUNC = 0;
    return 0;
}

// LOAD SAVED PARAMETERS FROM FRAM ---------------------------------------------
// this function loads minute counters, serial number, manufacturer name
// PID controller parameters
int load_parameters(void)
{
    static int STATE_FUNC = 0;
    extern unsigned long min_counter, min_on_counter;
    extern char man[4];
    extern char serial_n[6];
    
#ifdef _PID
    extern int pid_V_coeff[3];
    extern int pid_I_coeff[3];
    extern int pid_V_18Vcoeff[3];
    static int i;
#endif
    
    int R0;
    
    switch(STATE_FUNC)
    {
        case 0:
            // this function should not return 0 until the end of reading
            STATE_FUNC++;
            break;
        case 1:
            if(!FLAGS.FRM && !FLAGS.TMP)
            {
                FLAGS.FRM = 1;                          // hold I2C bus
                FLAGS.TMP = 1;
                STATE_FUNC++;
            }
            break;
        case 2:
            // read saved counter value and update the actual
            if(!FRAM_read((unsigned int *)&R0, M_CNT_ADD_L))
            {   // low word
                min_counter = (unsigned long)R0;
                STATE_FUNC++;
            }
            break;
        case 3:
            if(!FRAM_read((unsigned int *)&R0, M_CNT_ADD_H))
            {   // high word
                min_counter = min_counter | ((unsigned long)R0 << 16);
                STATE_FUNC++;
            }
            break;
        case 4:
            // read saved counter value and update the actual
            if(!FRAM_read((unsigned int *)&R0, M_ACT_ADD_L))
            {   // low word
                min_on_counter = (unsigned long)R0;
                STATE_FUNC++;
            }
            break;
        case 5:
            if(!FRAM_read((unsigned int *)&R0, M_ACT_ADD_H))
            {   // high word
                min_on_counter = min_on_counter | ((unsigned long)R0 << 16);
                STATE_FUNC++;
            }
            break;
        case 6:
            if(!FRAM_read((unsigned int *)&R0, MAN_L))
            {   // low part, first two chars
                man[0] = (char)R0;
                man[1] = (char)((unsigned int)R0 >> 8);
                STATE_FUNC++;
            }
            break;
        case 7:
            if(!FRAM_read((unsigned int *)&R0, MAN_H))
            {   // high part, last two chars
                man[2] = (char)R0;
                man[3] = (char)((unsigned int)R0 >> 8);
                STATE_FUNC++;
            }
            break;
        case 8:
            if(!FRAM_read((unsigned int *)&R0, SERIAL_L))
            {   // low part, last two chars
                serial_n[0] = (char)R0;
                serial_n[1] = (char)((unsigned int)R0 >> 8);
                STATE_FUNC++;
            }
            break;
        case 9:
            if(!FRAM_read((unsigned int *)&R0, SERIAL_M))
            {   // mid part, two central chars
                serial_n[2] = (char)R0;
                serial_n[3] = (char)((unsigned int)R0 >> 8);
                STATE_FUNC++;
            }
            break;
        case 10:
            if(!FRAM_read((unsigned int *)&R0, SERIAL_H))
            {   // high part, last two chars
                serial_n[4] = (char)R0;
                serial_n[5] = (char)((unsigned int)R0 >> 8);
#ifdef _PID
                i = 0;
                STATE_FUNC++;
#else
                FLAGS.FRM = 0;                      // release I2C bus
                STATE_FUNC = 0;
#endif
            }
            break;
#ifdef _PID
        case 11:
            if(!ERR_FLAGS.MEM)
            {   // no error -> load parameters from FRAM
                if(i < 3)
                {   // read voltage mode parameters
                    if(!FRAM_read((unsigned int *)&R0, (PID_V_ADD + (i << 1))))
                        {   // read parameter
                        pid_V_coeff[i++] = R0;
                        }                     
                }
                else if(i < 6)
                     {   // read current mode parameters
                        if(!FRAM_read((unsigned int *)&R0, (PID_V_ADD + (i << 1))))
                        {   // read parameter
                            pid_I_coeff[(i++) - 3] = R0;
                        }
                     }
                else if (i < 9)
                    {
                        if(!FRAM_read((unsigned int *)&R0, (PID_V_ADD + (i << 1))))
                        {   // read parameter
                            pid_V_18Vcoeff[(i++) -6] = R0;    
                        }    
                    }
                     else
                    {   // end
                    FLAGS.FRM = 0;                      // release I2C bus
                    STATE_FUNC = 0;
                    }
            }
            else
            {   // load flash default
                pid_V_coeff[0] = _kp_Vdef;
                pid_V_coeff[1] = _ki_Vdef;
                pid_V_coeff[2] = _kd_Vdef;
                
                pid_V_18Vcoeff[0] = 200;
                pid_V_18Vcoeff[1] = 1000;
                pid_V_18Vcoeff[2] =0;
                
                pid_I_coeff[0] = _kp_Idef;
                pid_I_coeff[1] = _ki_Idef;
                pid_I_coeff[2] = _kd_Idef;
                
                FLAGS.FRM = 0;                      // release I2C bus
                STATE_FUNC = 0;
            }
            break;
#endif
    }
        
    return STATE_FUNC;    
}

// SAVE minute counters to FRAM ------------------------------------------------
int save_m_counters(void)
{
    static int STATE_FUNC = 0;
    
    extern unsigned long min_counter;
    extern unsigned long min_on_counter;
    
    switch(STATE_FUNC)
    {
        case 0:
            // this function should not return 0 until the end of writing
            STATE_FUNC++;
            break;
        case 1:
            if(!FRAM_write(M_CNT_ADD_L, (int)(min_counter & 0x0000FFFF)))
                STATE_FUNC++;
            break;
        case 2:
            if(!FRAM_write(M_CNT_ADD_H, (int)(((unsigned long)min_counter >> 16) & 0x0000FFFF)))
                STATE_FUNC++;
            break;
        case 3:
            if(!FRAM_write(M_ACT_ADD_L, (int)(min_on_counter & 0x0000FFFF)))
                STATE_FUNC++;
            break;
        case 4:
            if(!FRAM_write(M_ACT_ADD_H, (int)(((unsigned long)min_on_counter >> 16) & 0x0000FFFF)))
                STATE_FUNC = 0;
            break;
    }
    
    return STATE_FUNC;
}

